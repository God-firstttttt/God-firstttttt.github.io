<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue.js（一）</title>
    <link href="/2021/03/08/Vue%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%20%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <url>/2021/03/08/Vue%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%20%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue基础学习-第一天"><a href="#Vue基础学习-第一天" class="headerlink" title="Vue基础学习 第一天"></a>Vue基础学习 第一天</h1><h2 id="一、Vue的基本介绍与使用"><a href="#一、Vue的基本介绍与使用" class="headerlink" title="一、Vue的基本介绍与使用"></a>一、Vue的基本介绍与使用</h2><h3 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h3><ul><li>Vue (读音 /vjuː/，类似于 view) 是一套用于<strong>构建用户界面的渐进式JavaScript框架</strong></li><li>特点:易用、灵活、高效</li><li>版本：2.6</li><li>作者：尤雨溪</li><li>兼容：IE8及以下不兼容</li></ul><h3 id="2、使用步骤"><a href="#2、使用步骤" class="headerlink" title="2、使用步骤"></a>2、使用步骤</h3><ol><li>引入vue.js</li></ol><ul><li>开发版本(development)：警告、提示、没有压缩</li><li>生产版本（production）：部署上线时候用的，删除了警告、提示、压缩了代码</li></ul><ol start="2"><li>创建挂载节点</li></ol><ul><li><strong>注意：</strong>千万不能是body或者html</li></ul><ol start="3"><li>实例化Vue对象</li></ol><ul><li>el：挂载节点的选择器</li><li>data：模版中用到的所有数据<ul><li></li><li></li></ul></li></ul><h3 id="3、MVVM"><a href="#3、MVVM" class="headerlink" title="3、MVVM"></a>3、MVVM</h3><ul><li>M    model（data里面的数据）</li><li>V  view(视图，就是模板)</li><li>VM (虚拟模型)</li></ul><p>注意：data里面的数据一旦变化，模板里面会自动更新！</p><h3 id="4、插值表达式"><a href="#4、插值表达式" class="headerlink" title="4、插值表达式"></a>4、插值表达式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;app&#x27;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;msg+&#x27;----&#x27;+123&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&#x27;msg&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&#x27;msg1&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-pre</span>&gt;</span>&#123;&#123;msg1&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//   1、v-text指令用于将数据填充到标签中，作用于插值表达式类似，但是没有闪动问题</span></span><br><span class="javascript">    <span class="hljs-comment">//   2、v-html指令用于将HTML片段填充到标签中，但是可能有安全问题</span></span><br><span class="javascript">    <span class="hljs-comment">//   3、v-pre用于显示原始信息</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> vue = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data: &#123;<br><span class="javascript">            msg: <span class="hljs-string">&#x27;hello Vue!&#x27;</span>,</span><br><span class="handlebars"><span class="xml">            msg1: &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>&#x27;</span></span><br>        &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure><h2 id="二、Vue的相关指令"><a href="#二、Vue的相关指令" class="headerlink" title="二、Vue的相关指令"></a>二、Vue的相关指令</h2><h3 id="1、指令的定义："><a href="#1、指令的定义：" class="headerlink" title="1、指令的定义："></a>1、指令的定义：</h3><ul><li>指令就是自定义属性</li><li>通常用法：**&lt;标签 v-指令名=”变量/表达式” /&gt;**</li></ul><h3 id="2、常用指令"><a href="#2、常用指令" class="headerlink" title="2、常用指令"></a>2、常用指令</h3><h4 id="1、v-html"><a href="#1、v-html" class="headerlink" title="1、v-html"></a>1、v-html</h4><ul><li><p>渲染数据！ 体验感更好！  </p></li><li><p><strong>可以转义HTML字符串内容！</strong>将其当html标签解析后输出，  类似于原生的innerHTML</p></li><li><p>可能有安全问题, 一般只在可信任内容上使用 <code>v-html</code>，<strong>永不</strong>用在用户提交的内容上</p></li></ul><h4 id="2、v-text"><a href="#2、v-text" class="headerlink" title="2、v-text"></a>2、v-text</h4><ul><li>渲染数据！ 体验感更好！ </li><li><strong>不可以转义HTML字符串内容！</strong>如果数据中有HTML标签会将html标签一并输出，类似于原生的innerText</li><li>**注意:**在指令中不要写插值语法  直接写对应的变量名称</li><li>在 v-text 中 赋值的时候不要在写 插值语法</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>　　<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- 输出：html标签在渲染的时候被解析 --&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- 输出：&lt;span&gt;通过双括号绑定&lt;/span&gt; --&gt;</span><br>    <br>　　<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- 输出：&lt;span&gt;html标签在渲染的时候被源码输出&lt;/span&gt; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">　　<span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">　　el: <span class="hljs-string">&quot;#app&quot;</span>,</span><br>　　data: &#123;<br><span class="handlebars"><span class="xml">　　　　message: &quot;<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>通过双括号绑定<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>&quot;,</span></span><br><span class="handlebars"><span class="xml">　　　　html: &quot;<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>html标签在渲染的时候被解析<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>&quot;,</span></span><br><span class="handlebars"><span class="xml">　　　　text: &quot;<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>html标签在渲染的时候被源码输出<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>&quot;,</span></span><br>　　&#125;<br> &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3、v-bind"><a href="#3、v-bind" class="headerlink" title="3、v-bind"></a>3、v-bind</h4><ul><li><strong>属性绑定！</strong> 给HTML标签的原生属性，让这些原生属性也支持属性和表达式！</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 绑定一个属性 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;imageSrc&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 缩写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imageSrc&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>绑定对象<ul><li>我们可以给v-bind:class 一个对象，以动态地切换class。</li><li>注意：v-bind:class指令可以与普通的class特性共存</li></ul></li><li></li></ul><h4 id="4、v-once"><a href="#4、v-once" class="headerlink" title="4、v-once"></a>4、v-once</h4><ul><li>作用：一次性绑定数据，数据渲染之后，将来数据变化了，页面也不更新！</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;标签 v-once&gt;&#123;&#123;变量&#125;&#125;&lt;/标签&gt;<br>&lt;标签 v-once v-html=&quot;变量&quot;&gt;&lt;/标签&gt;<br></code></pre></td></tr></table></figure><h4 id="5、v-on"><a href="#5、v-on" class="headerlink" title="5、v-on"></a>5、v-on</h4><ul><li>作用：绑定事件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;标签 v-on:事件类型=&quot;事件函数&quot;&gt;&lt;/标签&gt; <br>&lt;标签 v-on:事件类型=&quot;事件函数()&quot;&gt;&lt;/标签&gt; <br>简写：<br> &lt;标签 @事件类型=&quot;事件函数&quot;&gt;&lt;/标签&gt;<br></code></pre></td></tr></table></figure><ul><li>事件写在methods中</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;<br>   el:<span class="hljs-string">&quot;xx&quot;</span>,<br>   data:&#123;xxx&#125;,<br>   methods:&#123;<br>     事件函数()&#123;<br>     ...<br>     &#125;<br>   &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><p>传参：参数一一对应</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;标签 @事件类型=&quot;事件函数(实参)&quot; /&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;<br>   el:<span class="hljs-string">&quot;&quot;</span>,<br>  data:&#123;&#125;,<br>  methods:&#123;<br>    事件函数(形参)&#123; ... &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：</p><ul><li><p><strong>事件函数里面的this都是当前vue实例对象！</strong></p></li><li><p><strong>methods里面的所有的事件函数都是当前vue实例的方法！</strong></p></li><li><p>当形参单个存在，实参没有传的时候，形参就是事件对象</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;app&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&#x27;num++&#x27;</span>&gt;</span>点击1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;num++&#x27;</span>&gt;</span>点击2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;handle&#x27;</span>&gt;</span>点击3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;handle()&#x27;</span>&gt;</span>点击4<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;handle2(123,$event,456)&#x27;</span>&gt;</span>点击5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;handle3&#x27;</span>&gt;</span>点击6<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-comment">//注意点：属性之间不要忘记逗号；</span></span><br><span class="javascript">      <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">          el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>          data: &#123;<br>              num: 0,<br>          &#125;,<br><span class="javascript">          <span class="hljs-comment">//methods 中主要定义一些函数</span></span><br>          methods: &#123;<br><span class="javascript">              handle: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                  <span class="hljs-comment">// 此时的this指向Vue的实例对象</span></span><br><span class="javascript">                  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === vm);</span><br><span class="javascript">                  <span class="hljs-built_in">this</span>.num++;</span><br>              &#125;,<br><span class="javascript">              <span class="hljs-comment">//参数要一一对应</span></span><br><span class="javascript">              handle2: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, e, y</span>) </span>&#123;</span><br><span class="javascript">                  <span class="hljs-built_in">console</span>.log(x, e, y);</span><br><span class="javascript">                  <span class="hljs-built_in">this</span>.num++;</span><br>              &#125;,<br><span class="javascript">              <span class="hljs-comment">//当调用函数不传参数时，形参就是事件对象</span></span><br><span class="javascript">              handle3: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="javascript">                  <span class="hljs-built_in">console</span>.log(e.target);</span><br><span class="javascript">                  <span class="hljs-built_in">this</span>.num++;</span><br>              &#125;<br>          &#125;<br>      &#125;)<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="6、v-model"><a href="#6、v-model" class="headerlink" title="6、v-model"></a>6、v-model</h4></li><li><p>作用： 实现数据的双向绑定</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>&lt;input type=<span class="hljs-string">&quot;text&quot;</span> v-model=<span class="hljs-string">&quot;msg&quot;</span> /&gt; <br>&lt;/div&gt;<br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br><span class="hljs-keyword">new</span> Vue(&#123;<br>  el:<span class="hljs-string">&quot;#app&quot;</span>,<br>    data:&#123;<br>    msg:<span class="hljs-string">&quot;&quot;</span>   <span class="hljs-comment">// 数据实现双向绑定</span><br>    &#125;<br>  &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="7、v-pre"><a href="#7、v-pre" class="headerlink" title="7、v-pre"></a>7、v-pre</h4><ul><li>作用：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</li></ul><h4 id="8、v-cloak"><a href="#8、v-cloak" class="headerlink" title="8、v-cloak"></a>8、v-cloak</h4><ul><li>作用：解决插值表达式刷新浏览器过程中编译慢，显示花括号的问题。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">[v-cloak] &#123;<br>  display: none;<br>&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-cloak</span>&gt;</span><br>  &#123;&#123; message &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3、事件修饰符"><a href="#3、事件修饰符" class="headerlink" title="3、事件修饰符"></a>3、事件修饰符</h3><ol><li>含义：帮助我们实现一些方便操作（比如：阻止默认事件、阻止冒泡、捕获触发、等等！）</li><li>写法：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;标签 @事件类型.修饰符=&quot;事件函数&quot;&gt;&lt;/标签&gt;     <br>&lt;标签 @事件类型.修饰符1.修饰符2=&quot;事件函数&quot;&gt;&lt;/标签&gt;<br></code></pre></td></tr></table></figure><ol start="3"><li>事件修饰符：</li></ol><ul><li><ul><li><ul><li><code>.stop</code>:阻止冒泡</li><li><code>.prevent</code>：阻止默认事件</li><li><code>.capture</code>：阻止捕获触发事件</li><li><code>.self</code>：只能自身触发</li><li><code>.once</code>：只触发一次</li><li><code>.passive</code>：滚动事件的默认行为 (即滚动行为) 将会立即触发</li></ul></li></ul></li></ul><h3 id="4、按键修饰符"><a href="#4、按键修饰符" class="headerlink" title="4、按键修饰符"></a>4、按键修饰符</h3><ul><li><strong>按键修饰符是给按键相关事件的！</strong></li><li><strong>基本上都是用在：input、textarea</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;标签 @事件类型.修饰符=&quot;事件函数&quot;&gt;&lt;/标签&gt;<br></code></pre></td></tr></table></figure><ul><li><p>按键修饰符:</p></li><li><ul><li><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“删除”和“退格”键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li><li>目前版本26个字母按键都已经绑定</li></ul></li></ul></li><li><p>自定义按键修饰符:</p><p><strong><code>Vue.config.keyCodes.按键修饰符名 = 按键的keycode码！</code></strong></p><p>一般放在实例化之前去配置！</p></li></ul><h2 id="三、Vue样式"><a href="#三、Vue样式" class="headerlink" title="三、Vue样式"></a>三、Vue样式</h2><h3 id="1、绑定class"><a href="#1、绑定class" class="headerlink" title="1、绑定class"></a>1、绑定class</h3><ul><li>对象形式</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;标签 :class=&quot;&#123; class名1:变量1，class名2:变量2 &#125;&quot; /&gt;<br></code></pre></td></tr></table></figure><ul><li>数组</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;标签 :class=&quot;[变量1，变量2,&#x27;class名1&#x27;,&#x27;class名2&#x27;]&quot; /&gt;<br></code></pre></td></tr></table></figure><ul><li>属性绑定</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;标签 :class=&quot;条件 ？ &#x27;class名1&#x27;:&#x27;class名2&#x27; &quot; /&gt;<br></code></pre></td></tr></table></figure><h3 id="2、绑定样式"><a href="#2、绑定样式" class="headerlink" title="2、绑定样式"></a>2、绑定样式</h3><ul><li>对象</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;标签 :style=&quot;&#123; css属性名名1:变量1，css属性名2:变量2 &#125;&quot; /&gt;<br></code></pre></td></tr></table></figure><ul><li>数组</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;标签 :style=&quot;[变量1，变量2]&quot; /&gt;<br>变量1:&#123; css属性名:css属性值 &#125;<br>变量2:&#123; css属性名:css属性值 &#125;<br></code></pre></td></tr></table></figure><ul><li>属性绑定（常用）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;标签 :style=&quot;&#x27;background-color:&#x27;+bgc+&#x27;;font-size:&#x27;+num+&#x27;px;&#x27;&quot; /&gt;<br><br>&lt;标签 :style=&quot;`font-size:$&#123;a&#125;;border-color:$&#123;b&#125;`&quot; /&gt;<br></code></pre></td></tr></table></figure><ul><li><ul><li></li></ul></li><li><ul><li></li></ul></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js（四）</title>
    <link href="/2021/02/27/Node.js%20%E7%AC%AC%E5%9B%9B%E5%A4%A9/"/>
    <url>/2021/02/27/Node.js%20%E7%AC%AC%E5%9B%9B%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js-第四天"><a href="#Node-js-第四天" class="headerlink" title="Node.js 第四天"></a>Node.js 第四天</h1><h2 id="一、Express插件"><a href="#一、Express插件" class="headerlink" title="一、Express插件"></a>一、Express插件</h2><h3 id="1、什么是-Express"><a href="#1、什么是-Express" class="headerlink" title="1、什么是 Express"></a>1、什么是 Express</h3><p>   基于 Node.js 平台，快速、开放、极简的 Web 开发框架, 本质上就是一个 npm 的第三方包, 给我们提供了快速创建 web 服务器的方法</p><h3 id="2、Express的应用场景"><a href="#2、Express的应用场景" class="headerlink" title="2、Express的应用场景"></a>2、Express的应用场景</h3><ol><li><p>开发 Web 网站服务器</p></li><li><p>API 接口服务器</p></li></ol><h3 id="3、安装-Express"><a href="#3、安装-Express" class="headerlink" title="3、安装 Express"></a>3、安装 Express</h3><p>   在项目的根目录下, 执行命令: <code>npm i express@4.17.1</code></p><h3 id="4、Express使用"><a href="#4、Express使用" class="headerlink" title="4、Express使用"></a>4、Express使用</h3><ol><li>基本使用及对get、post请求进行监听</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入包</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><br><span class="hljs-comment">// 创建一个服务器实例</span><br><span class="hljs-keyword">const</span> app = express();<br><br><span class="hljs-comment">// 监听用户的get请求</span><br>app.get(<span class="hljs-string">&#x27;/userinfo&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 使用send方法向客户端响应一个json字符串</span><br>    res.send(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xh&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">155</span> &#125;)<br>&#125;);<br><br><span class="hljs-comment">// 注意：/ 表示我们的根路径</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 使用send方法向客户端响应一个json字符串</span><br>    res.send(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xh&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">155</span> &#125;)<br>&#125;);<br><br><span class="hljs-comment">// 监听用户post请求</span><br>app.post(<span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.send(<span class="hljs-string">&#x27;登录成功！&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">// 启动服务</span><br>app.listen(<span class="hljs-number">3006</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;启动服务成功：http://localhost:3006&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>获取动态参数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入包</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">// 创建web服务器实例</span><br><span class="hljs-keyword">const</span> app = express();<br><span class="hljs-comment">//  id标明这是一个动态查询参数，实际请求的时候不需要加：</span><br>app.get(<span class="hljs-string">&#x27;/my/article/deletecate/:id/:name&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//  多个动态参数以/:拼接</span><br>    <span class="hljs-comment">//获取url上的动态参数，结果是一个对象      </span><br>    <span class="hljs-built_in">console</span>.log(req.params.id, req.params.name);<br>    res.send(req.params);<br>&#125;);<br><span class="hljs-comment">// 启动服务，监听端口</span><br>app.listen(<span class="hljs-number">3006</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;服务运行:http://localhost:3006/my/article/deletecate/20/zs&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="3"><li><p>托管动态资源并添加资源前缀</p><p><strong>注意：</strong>优化为绝对地址</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入包</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-comment">// 创建web服务器实例</span><br><span class="hljs-keyword">const</span> app = express();<br><br><span class="hljs-comment">//  托管assets文件夹下所有的静态资源 express.static()</span><br><span class="hljs-comment">//   为静态资源的路径添加一个公共的资源前缀</span><br>app.use(<span class="hljs-string">&#x27;/public&#x27;</span>, express.static(path.join(__dirname,<span class="hljs-string">&#x27;./assets&#x27;</span>)));<br><br><span class="hljs-comment">// 启动服务，监听端口</span><br>app.listen(<span class="hljs-number">3006</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;服务运行:http://localhost:3006/public&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="二、nodemon包"><a href="#二、nodemon包" class="headerlink" title="二、nodemon包"></a>二、nodemon包</h2><p> 每次修改 node.js 服务端代码都需要重新启动服务, 比较繁琐, nodemon 插件可以实时监测文件的动态变化,</p><p> 并当文件内容变化时自动重启服务</p><ul><li><p>全局安装: </p><p>  <code>npm i -g nodemon</code></p></li><li><p>使用方法:</p><p>  <code>nodemon index.js</code></p></li></ul><h2 id="三、路由"><a href="#三、路由" class="headerlink" title="三、路由"></a>三、路由</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>   路由在广义上理解就是指一种映射关系, 在 node.js 中指的是客户端的请求和服务端处理函数的映射关系,Express 路由包括 3 部分: 请求的 URL, 请求的类型, 处理函数</p><h3 id="2、定义路由方法"><a href="#2、定义路由方法" class="headerlink" title="2、定义路由方法"></a>2、定义路由方法</h3><p>   app.Method(URL, handler)</p><ul><li>创建路由实例：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><br><span class="hljs-comment">// 生成一个路由实例对象</span><br><span class="hljs-keyword">const</span> router = express.Router();<br><br><span class="hljs-comment">// 再向路由实例对象上挂载</span><br>router.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.send(<span class="hljs-string">&#x27;hello!&#x27;</span>)<br>&#125;);<br>router.get(<span class="hljs-string">&#x27;/api&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.send(<span class="hljs-string">&#x27;world&#x27;</span>)<br>&#125;);<br>router.post(<span class="hljs-string">&#x27;/api&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.send(<span class="hljs-string">&#x27;hello!123&#x27;</span>)<br>&#125;);<br><span class="hljs-comment">//注意要暴露出去</span><br><span class="hljs-built_in">module</span>.exports = router;<br></code></pre></td></tr></table></figure><ul><li>调用路由实例：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./10-创建路由模块&#x27;</span>);<span class="hljs-comment">//为穿建路由的自定义模块</span><br><br><span class="hljs-comment">// 创建web服务器实例</span><br><span class="hljs-keyword">const</span> app = express();<br><br><span class="hljs-comment">// 添加第一个参数： 表示请求路由url的公共前缀</span><br>app.use(<span class="hljs-string">&#x27;/my&#x27;</span>, router);<br><br>app.listen(<span class="hljs-number">3006</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;运行成功:http://localhost:3006/my&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="四、中间件"><a href="#四、中间件" class="headerlink" title="四、中间件"></a>四、中间件</h2><h3 id="1、什么是中间件？"><a href="#1、什么是中间件？" class="headerlink" title="1、什么是中间件？"></a>1、什么是中间件？</h3><p>​    泛指业务流程的中间处理环节, Express 的中间件即是指响应数据的中间环节, 本质上就是一个处理函数</p><h3 id="2、中间件的参数列表"><a href="#2、中间件的参数列表" class="headerlink" title="2、中间件的参数列表"></a>2、中间件的参数列表</h3><p>​    包含 req 请求对象, res 响应对象 和 next 回调函数, 注意路由处理函数中没有 next 参数</p><h3 id="3、next-参数的作用"><a href="#3、next-参数的作用" class="headerlink" title="3、next 参数的作用"></a>3、next 参数的作用</h3><p>   用来实现多个中间件连续调用的关键, 一个中间件函数内必须调用 next() 将控制权传递给下一个中间件功能, 否则该请求将被挂起。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个中间件函数</span><br><span class="hljs-keyword">const</span> middleware = <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;正在处理请求&#x27;</span>);<br>    <span class="hljs-comment">// 调用next() 表示当前中间件处理函数， 移交给下一个中间件或路由处理</span><br>    next();<br>&#125;;<br><span class="hljs-comment">//使用中间件</span><br>app.use(middleware);<br><span class="hljs-comment">//可以简写为：</span><br>app.use(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;执行第二个中间件&#x27;</span>);<br>    next();<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="4、中间件的范围"><a href="#4、中间件的范围" class="headerlink" title="4、中间件的范围"></a>4、中间件的范围</h3><ul><li>全局中间件: 任何请求到达服务器之后都会触发的中间件</li><li>局部中间件: 只有匹配当前路由的请求到达服务器才会触发的中间件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个局部中间件函数</span><br><span class="hljs-keyword">const</span> mw = <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;使用了局部中间件&#x27;</span>);<br>    next();<br>&#125;;<br><br><span class="hljs-comment">// 注册局部中间件（只对匹配当前路由的请求生效），放在注册路由参数的第二个参数位置</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, mw, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.send(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>多个局部生效的中间件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 注册第一个中间件</span><br><span class="hljs-keyword">const</span> mw1 = <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>    req.name = <span class="hljs-string">&#x27;zs&#x27;</span>;<br>    req.pwd = <span class="hljs-string">&#x27;asd455&#x27;</span>;<br>    res.age = <span class="hljs-string">&#x27;20&#x27;</span>;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;执行第一个中间件&#x27;</span>);<br>    next();<br>&#125;<br><br><span class="hljs-comment">// 注册第二个中间件</span><br><span class="hljs-keyword">const</span> mw2 = <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;执行第二个中间件&#x27;</span>);<br>    next();<br>&#125;<br><span class="hljs-comment">//或者直接逗号隔开</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, [mw1, mw2], <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(req.name, req.pwd, res.age);<br>    res.send(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="5、中间件的注意事项"><a href="#5、中间件的注意事项" class="headerlink" title="5、中间件的注意事项"></a>5、中间件的注意事项</h3><ol><li><p>全局中间件的注册要放在路由定义之前</p></li><li><p>对于一个客户端的发送过来的请求, 可以调用多个中间件进行处理</p></li><li><p>中间件的处理函数中一定要有 next() 调用</p></li><li><p>next 函数之后不用再写和业务无关的代码</p></li><li><p>多个中间件之间共享 req 和 res 对象</p></li></ol><h3 id="6、中间件的分类"><a href="#6、中间件的分类" class="headerlink" title="6、中间件的分类"></a>6、中间件的分类</h3><ol><li><p>应用层中间件</p></li><li><p>路由级中间件 router(url,中间件,fn())</p></li><li><p>错误处理中间件 (err,req,res,fn())</p><p>​        注意： 一定要放在所有路由之后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 错误级别中间件一定要放在末尾</span><br>app.use(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;错误信息：&#x27;</span> + err.message);<br>        res.send(&#123; <span class="hljs-attr">status</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">message</span>: err.message &#125;)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>内置中间件</p></li><li><p>第三方中间件</p></li></ol><h3 id="7、内置中间件"><a href="#7、内置中间件" class="headerlink" title="7、内置中间件"></a>7、内置中间件</h3><ul><li><p>express.static() 快速托管静态资源的中间件</p></li><li></li><li><p>express.json()  解析客户端传递的 json 格式的请求体数据,处理post表单提交的application/json 格式的数据</p></li><li><p>express.urlencoded() 解析客户端传递的 urlencoded 编码形式的请求体数据，处理post表单提交的application/x-www-form-urlencode 格式的数据</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 处理post表单提交的application/json 格式的数据</span><br>app.use(express.json());<br><br><span class="hljs-comment">// 处理post表单提交的application/x-www-form-urlencode 格式的数据</span><br>app.use(express.urlencoded(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))<br></code></pre></td></tr></table></figure><h3 id="8、第三方中间件"><a href="#8、第三方中间件" class="headerlink" title="8、第三方中间件"></a>8、第三方中间件</h3><p> 非 Express 内置给我们的, 而是由第三方个人或公司开发的中间件, 我们可以先下载再配置来进行使用</p><p> 示例: 使用 body-parse 这个中间件来解析请求体的数据</p><ol><li><p>运行命令下载 <code>npm i body-parse</code> </p></li><li><p>使用 require() 方法引入</p></li><li><p>使用 app.use() 方法注册</p></li></ol><h3 id="9、自定义中间件"><a href="#9、自定义中间件" class="headerlink" title="9、自定义中间件"></a>9、自定义中间件</h3><p>实现步骤: </p><ol><li><p>定义全局中间件</p></li><li><p>监听 req 的 data 事件</p></li><li><p>监听 req 的 end 事件</p></li><li><p>使用 querystring 模块解析请求体数据</p></li><li><p>把解析后的数据挂载到 req.body 上</p></li></ol><ul><li><p>qs.stringify()把对象转换成查询字符串</p></li><li><p>qs.parse()把查询字符串转换为对象</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入内置的querystring</span><br><span class="hljs-keyword">const</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>);<br><span class="hljs-keyword">const</span> bodyParser = <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br><br>    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span>;<br><br>    <span class="hljs-comment">// 监听req的data事件（post表单提交的数据量很多，分批发送）</span><br>    req.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// chunk每次发送到服务器的数据片段</span><br>        <span class="hljs-built_in">console</span>.log(chunk); <span class="hljs-comment">//默认是utf-8二进制</span><br>        str += chunk;<br>    &#125;);<br>    <span class="hljs-comment">// 监听req的end事件（服务器已经接收到客户端发送的完整数据）</span><br>    req.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(str); <span class="hljs-comment">//获取请求体的数据，键值对的字符串</span><br>        <span class="hljs-keyword">const</span> type = req.get(<span class="hljs-string">&#x27;Content-Type&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(type);<br>        <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;application/json&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 把转换后的参数对象挂载到req.body上，共享给构面的中间件或路由使用</span><br>            req.body = <span class="hljs-built_in">JSON</span>.parse(str);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 把转换后的参数对象挂载到req.body上，共享给构面的中间件或路由使用</span><br>            req.body = qs.parse(str);<br>        &#125;<br>        next()<br>    &#125;);<br><br>&#125;;<br><span class="hljs-comment">// 向外暴露</span><br><span class="hljs-built_in">module</span>.exports = bodyParser;<br></code></pre></td></tr></table></figure><h3 id="10、cors概念了解"><a href="#10、cors概念了解" class="headerlink" title="10、cors概念了解"></a>10、cors概念了解</h3><ol><li><p>定义</p><p>(Cross-Origin Resource Sharing) 跨域资源共享, 由一系列的 HTTP 响应头组成, 这些响应头决定了浏览器是否阻止前端 js 代码发出跨域请求。</p></li><li><p>CORS 的响应头部</p><p>(1) Access-Control-Allow-Origin: url/*   指定了允许访问该资源的url </p><p>(2) Access-Control-Allow-Headers: a, b, c  指定了允许发送哪些请求头</p><p>(3) Access-Control-Allow-Methods: GET, POST 指定了允许发送何种类型的请求</p></li><li><p>cors 请求的分类</p><p>   简单请求: 请求方式为 GET/POST/HEAD 之一; 无自定义请求头字段</p><p>   预检请求: 请求方式不为 GET/POST/HEAD 之一; 存在自定义请求头字段; 发送了 application/json 格式数据</p><p>   浏览器会先发送一个 OPTIONS 请求进行预检, 以确认服务器是否允许该实际请求, 完成后再发送真正的请求</p></li></ol><h3 id="11、案列：express写接口"><a href="#11、案列：express写接口" class="headerlink" title="11、案列：express写接口"></a>11、案列：express写接口</h3><ul><li>在文件一中编写接口路由</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> router = express.Router();<br><br><span class="hljs-comment">// 编写一个get接口，返回的数据格式同大事件接口</span><br>router.get(<span class="hljs-string">&#x27;/get&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 获取请求参数对象：req.query;获取动态参数：req.params</span><br>    <span class="hljs-keyword">const</span> data = req.query;<br>    <span class="hljs-built_in">console</span>.log(data);<br>    res.send(&#123;<br>        status: <span class="hljs-number">0</span>,<br>        message: <span class="hljs-string">&#x27;获取数据成功！&#x27;</span>,<br>        data<br>    &#125;)<br>&#125;);<br><br><span class="hljs-comment">// 编写一个post接口</span><br>router.post(<span class="hljs-string">&#x27;/post&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> data = req.body;<br>    <span class="hljs-built_in">console</span>.log(data);<br>    res.send(&#123;<br>        status: <span class="hljs-number">0</span>,<br>        message: <span class="hljs-string">&#x27;提交数据成功!&#x27;</span>,<br>        data<br>    &#125;)<br>&#125;);<br><br><span class="hljs-comment">// 编写一个delete接口</span><br>router.delete(<span class="hljs-string">&#x27;/delete&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br><br>    res.send(&#123;<br>        status: <span class="hljs-number">0</span>,<br>        message: <span class="hljs-string">&#x27;删除数据成功!&#x27;</span>,<br><br>    &#125;)<br>&#125;);<br><span class="hljs-built_in">module</span>.exports = router;<br></code></pre></td></tr></table></figure><ul><li>文件二中写接口</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//解决跨域问题</span><br><span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>);<br><span class="hljs-keyword">const</span> app = express();<br><span class="hljs-comment">// 引入路由模块</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./19-apiRouter&#x27;</span>);<span class="hljs-comment">//指文件一的相对路径</span><br><br><span class="hljs-comment">// 在路由之前配置中间件</span><br>app.use(express.urlencoded(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;));<br>app.use(express.json());<br><br><span class="hljs-comment">// 优先创建jsonp接口</span><br>app.get(<span class="hljs-string">&#x27;/api/jsonp&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(req.query.callback); <span class="hljs-comment">//客户端发送的回调函数</span><br>    <span class="hljs-comment">// 响应函数调用</span><br>    res.send(<span class="hljs-string">`</span><br><span class="hljs-string">   <span class="hljs-subst">$&#123; req.query.callback&#125;</span>(&#123;name:&#x27;zs&#x27;,age:10&#125;)</span><br><span class="hljs-string">    `</span>)<br>&#125;)<br><br><span class="hljs-comment">// 在路由之前 注册cors中间件</span><br>app.use(cors());<br><br><span class="hljs-comment">// 注册路由</span><br>app.use(<span class="hljs-string">&#x27;/api&#x27;</span>, router);<br><br><span class="hljs-comment">// 页面查找不到</span><br>app.use(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>    res.send(<span class="hljs-string">&#x27;404 页面找不到了&#x27;</span>);<br>    next()<br>&#125;)<br><br><span class="hljs-comment">//编写错误级别的中间件</span><br>app.use(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        res.send(&#123;<br>            status: <span class="hljs-number">1</span>,<br>            message: err.message<br>        &#125;)<br>    &#125;;<br>    next();<br>&#125;)<br><br>app.listen(<span class="hljs-number">3006</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;服务运行在：http://localhost:3006&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>运行文件二，在postman中进行测试</p>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js（六）</title>
    <link href="/2021/02/27/Node.js%E7%AC%AC%E5%85%AD%E5%A4%A9/"/>
    <url>/2021/02/27/Node.js%E7%AC%AC%E5%85%AD%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js第六天-前后端的身份认证"><a href="#Node-js第六天-前后端的身份认证" class="headerlink" title="Node.js第六天 前后端的身份认证"></a>Node.js第六天 前后端的身份认证</h1><h2 id="一、web开发模式"><a href="#一、web开发模式" class="headerlink" title="一、web开发模式"></a>一、web开发模式</h2><h3 id="1、主流的-Web-开发模式"><a href="#1、主流的-Web-开发模式" class="headerlink" title="1、主流的 Web 开发模式"></a>1、主流的 Web 开发模式</h3><ol><li><p>基于客户端渲染的方式</p></li><li><p>基于服务端渲染的方式</p></li></ol><h3 id="2、服务端渲染概念"><a href="#2、服务端渲染概念" class="headerlink" title="2、服务端渲染概念"></a>2、服务端渲染概念</h3><p>   服务端直接把数据动态拼接到 HTML 字符串中, 再把完整的 HTML 页面数据发送给客户端, 这样浏览器就可以直接渲染页面, 不需要进行 Ajax 请求的操作了</p><h3 id="3、服务端渲染的优点"><a href="#3、服务端渲染的优点" class="headerlink" title="3、服务端渲染的优点"></a>3、服务端渲染的优点</h3><ol><li><p>前端渲染更快, 用户体验更好 (不需要首次等待 Ajax 发送请求的过程)</p></li><li><p>有利于 SEO 搜索引擎读取权重词汇 (服务端响应的是完整带标签的 HTML 内容, 百度等爬虫更容器读取信息)</p></li></ol><h3 id="4、服务端渲染的缺点"><a href="#4、服务端渲染的缺点" class="headerlink" title="4、服务端渲染的缺点"></a>4、服务端渲染的缺点</h3><ol><li><p>需要额外的服务器资源, 以及完善的运维体系去管理</p></li><li><p>不利于前后端分离, 由于页面是在服务端进行输出的, 需要前端的代码和 Node.js 服务端部署在一起</p></li></ol><h3 id="5、前后端分离的开发模式"><a href="#5、前后端分离的开发模式" class="headerlink" title="5、前后端分离的开发模式"></a>5、前后端分离的开发模式</h3><p>   依赖于 Ajax 技术的广泛运用, 后端只负责提供 API 接口, 前端使用 Ajax 调用接口渲染页面的开发模式</p><h3 id="6、前后端分离的优点"><a href="#6、前后端分离的优点" class="headerlink" title="6、前后端分离的优点"></a>6、前后端分离的优点</h3><p>   (1) 开发体验好, 各司其职, 效率更高</p><p>   (2) 用户体验好, Ajax 可以在不刷新页面的情况下实现局部更新, 配合 loading 效果体验度较好</p><p>   (3) 减轻服务端的渲染压力, 因为页面最终是在每个用户的浏览器中生成的</p><h3 id="7、前后端分离的缺点"><a href="#7、前后端分离的缺点" class="headerlink" title="7、前后端分离的缺点"></a>7、前后端分离的缺点</h3><p>   (1) 前端渲染耗时, 首屏渲染的体验度不高</p><p>   (2) 不利用 SEO 搜索引擎优化</p><h2 id="二、身份认证"><a href="#二、身份认证" class="headerlink" title="二、身份认证"></a>二、身份认证</h2><h3 id="1、身份认证技术"><a href="#1、身份认证技术" class="headerlink" title="1、身份认证技术"></a>1、身份认证技术</h3><p>   身份认证(Authentication) 又叫 “鉴权”, “权限验证”, “身份验证”, 是指通过一定的手段, 完成用户身份的确认</p><p>  例如: 火车票检票, 微信支付密码等生活场景</p><p>​     Web 开发中的邮箱验证, 短信验证码, 滑动验证码等方式</p><h3 id="2、为什么需要身份认证"><a href="#2、为什么需要身份认证" class="headerlink" title="2、为什么需要身份认证"></a>2、为什么需要身份认证</h3><p>   网站的内容如果涉及到隐私性, 安全性 和 交易性, 即需要身份认证的机制来确保安全</p><h3 id="3、不同开发模式下的身份任证"><a href="#3、不同开发模式下的身份任证" class="headerlink" title="3、不同开发模式下的身份任证"></a>3、不同开发模式下的身份任证</h3><p>   (1) 服务端渲染的推荐使用 Session 认证机制</p><p>   (2) 前后端分离推荐使用 JWT 认证机制</p><h3 id="4、HTTP-协议的特点"><a href="#4、HTTP-协议的特点" class="headerlink" title="4、HTTP 协议的特点"></a>4、HTTP 协议的特点</h3><p>   HTTP 本身是一个无状态的协议, 它不会记录每次发送请求的用户信息, 这会导致服务器无法识别哪个用户发送了请求</p><p>​    如何解决上述的问题？</p><p>   可以借助 <strong>cookie 和 session</strong> 两种技术来存储用户的状态</p><h2 id="三、Cookie技术"><a href="#三、Cookie技术" class="headerlink" title="三、Cookie技术"></a>三、Cookie技术</h2><h3 id="1、什么是-Cookie"><a href="#1、什么是-Cookie" class="headerlink" title="1、什么是 Cookie?"></a>1、什么是 Cookie?</h3><p>   Cookie 是存储在用户浏览器的一段不超过 4KB 的字符串, 它是由一个名称(Name) 和 值(Value) 以及其他几个用于控制 Cookie 有效期, 安全性, 使用范围的可选属性组成的</p><h3 id="2、Cookie-的作用"><a href="#2、Cookie-的作用" class="headerlink" title="2、Cookie 的作用"></a>2、Cookie 的作用</h3><p>   不用域名下的 Cookie 信息是独立的, 每当客户端发送请求时, 会自动把当前域名下所有未过期的 Cookie添加到请求头, 一同发送到服务器</p><h3 id="3、Cookie-的特性"><a href="#3、Cookie-的特性" class="headerlink" title="3、Cookie 的特性"></a>3、Cookie 的特性</h3><p>   (1) 自动发送</p><p>   (2) 域名独立</p><p>   (3) 过期时限</p><p>   (4) 4 KB限制</p><h3 id="4、Cookie-的工作机制"><a href="#4、Cookie-的工作机制" class="headerlink" title="4、Cookie 的工作机制"></a>4、Cookie 的工作机制</h3><p>   客户端(浏览器)第一次发送请求到服务器, 服务器会以响应头的形式向浏览器写入 Cookie 保存, 之后浏览器每次发送请求到服务器都会自动将 Cookie 以请求头的形式发送过去</p><p>  Cookie的更多操作: <a href="https://www.runoob.com/js/js-cookies.html">https://www.runoob.com/js/js-cookies.html</a></p><h3 id="5、Cookie-技术的缺点"><a href="#5、Cookie-技术的缺点" class="headerlink" title="5、Cookie 技术的缺点"></a>5、Cookie 技术的缺点</h3><p>   Cookie 是存储在浏览器端的, 并且浏览器本身提供了读写 Cookie 的方法, 因此 Cookie 信息很容易被窃取和伪造,重要的隐私信息不建议存放在 Cookie 中</p><h3 id="6、如何解决上述的缺点"><a href="#6、如何解决上述的缺点" class="headerlink" title="6、如何解决上述的缺点"></a>6、如何解决上述的缺点</h3><p>   使用 Session 方案, 用户的状态信息在服务器生成和存储, 浏览器只负责保留一个 sessionID 秘钥, 每次发送请求时携带这个 sessionID 到服务器, 服务器根据这个唯一的 id 值查询对应的用户信息进行返回</p><h2 id="四、Session技术"><a href="#四、Session技术" class="headerlink" title="四、Session技术"></a>四、Session技术</h2><h3 id="1、Session-认证的局限性"><a href="#1、Session-认证的局限性" class="headerlink" title="1、Session 认证的局限性"></a>1、Session 认证的局限性</h3><p>   SessionID 需要借助 cookie 手段存放在浏览器, 当涉及到前端跨域请求后端接口的时候, 需要做额外的配置,才能实现 Session 的认证</p><h3 id="2、如何解决上述的缺点"><a href="#2、如何解决上述的缺点" class="headerlink" title="2、如何解决上述的缺点"></a>2、如何解决上述的缺点</h3><p>   当前端跨域请求后端接口时, 推荐使用 JWT 这种认证方式, 没有和 Cookie 的绑定关系</p><h3 id="3、什么是-JWT-JSON-Web-Token"><a href="#3、什么是-JWT-JSON-Web-Token" class="headerlink" title="3、什么是 JWT (JSON Web Token)?"></a>3、什么是 JWT (JSON Web Token)?</h3><p>   基于token的鉴权机制, 是前端目前最流行的跨域认证解决方案</p><h2 id="五、JWT的工作机制"><a href="#五、JWT的工作机制" class="headerlink" title="五、JWT的工作机制"></a>五、JWT的工作机制</h2><h3 id="1、JWT-的认证机制"><a href="#1、JWT-的认证机制" class="headerlink" title="1、JWT 的认证机制"></a>1、JWT 的认证机制</h3><p>   用户信息通过加密签名后 token 字符串的形式, 保存在客户端浏览器中. 服务器通过解密客户端传来的 token 字符串来认证用户的身份</p><h3 id="2、JWT-的组成部分"><a href="#2、JWT-的组成部分" class="headerlink" title="2、JWT 的组成部分"></a>2、JWT 的组成部分</h3><p>   通常由三部分组成, 使用英文符号.进行分隔: Header.Payload.Signature</p><p>   Header: 头部</p><p>   Payload: 有效荷载, 这里存放的是经过加密后的用户信息</p><p>   Signature: 签名</p><h3 id="3、JWT-使用方式"><a href="#3、JWT-使用方式" class="headerlink" title="3、JWT 使用方式"></a>3、JWT 使用方式</h3><p>   服务端签发 TOKEN 到客户端后, 可以存储到 localStorage 中, 每次发送请求前都要带上这个 TOKEN, 推荐放在HTTP 请求头的 Authorization 字段中 (大事件项目中处理方式一致)</p><p>在 Node.js项目中使用 JWT: </p><ol><li><p>先安装 JWT 包</p><p><code>npm i jsonwebtoken express-jwt</code></p></li></ol><p>  说明: jsonwebtoken 用于生成 Token 字符串信息; express-jwt 用于把 Token 字符串解析为 JSON 对象</p>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL的认识及基本使用</title>
    <link href="/2021/02/25/MySQL%E7%9A%84%E8%AE%A4%E8%AF%86%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/02/25/MySQL%E7%9A%84%E8%AE%A4%E8%AF%86%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL的认识及基本使用"><a href="#MySQL的认识及基本使用" class="headerlink" title="MySQL的认识及基本使用"></a>MySQL的认识及基本使用</h1><h2 id="一、数据库的相关概念"><a href="#一、数据库的相关概念" class="headerlink" title="一、数据库的相关概念"></a>一、数据库的相关概念</h2><h3 id="1、什么是数据库"><a href="#1、什么是数据库" class="headerlink" title="1、什么是数据库"></a>1、什么是数据库</h3><p>   数据库 (database) 是专门用来组织, 存储和管理数据的仓库</p><h3 id="2、数据库的分类"><a href="#2、数据库的分类" class="headerlink" title="2、数据库的分类"></a>2、数据库的分类</h3><p>目前企业开发中最常用的数据库有以下几种: </p><ol><li><p>MySQL 数据库 (最广泛和最流行的)</p></li><li><p>Oracle 数据库</p></li><li><p>SQL Server 数据库</p></li><li><p>Mongodb 数据库</p></li></ol><h3 id="3、传统数据库的组织结构"><a href="#3、传统数据库的组织结构" class="headerlink" title="3、传统数据库的组织结构"></a>3、传统数据库的组织结构</h3><p>即数据以什么形式来进行存储的, 类似于 excel 表格中的工作簿, 工作表, 数据行, 数据列这四部分, 传统数据库的组织结构分为:</p><p>   数据库 (database), 数据表(table), 数据行(row), 字段(field) 这四大组成部分</p><h3 id="4、安装mysql"><a href="#4、安装mysql" class="headerlink" title="4、安装mysql"></a>4、安装mysql</h3><p>使用 Mysql 数据库需要安装的软件</p><p>   (1) MySQL Server 提供数据存储和服务的软件</p><p>   (2) MySQL Workbench 可视化的 MySQL 管理工具</p><h2 id="二、SQL语句"><a href="#二、SQL语句" class="headerlink" title="二、SQL语句"></a>二、SQL语句</h2><h3 id="1、什么是-SQL"><a href="#1、什么是-SQL" class="headerlink" title="1、什么是 SQL?"></a>1、什么是 SQL?</h3><p>   SQL 的全称是 Structured Query Language, 即结构化的查询语言, 专门用来访问和处理数据库的编程语言</p><h3 id="2、SQL-的关键特点"><a href="#2、SQL-的关键特点" class="headerlink" title="2、SQL 的关键特点"></a>2、SQL 的关键特点</h3><p>   (1) SQL 是一门数据库编程语言</p><p>   (2) 使用 SQL 语言编写出来的代码, 叫做 SQL 语句</p><p>   (3) SQL 语言只能在关系型数据库中使用, 非关系型的数据库不支持</p><h3 id="3、SQL-语言的作用"><a href="#3、SQL-语言的作用" class="headerlink" title="3、SQL 语言的作用"></a>3、SQL 语言的作用</h3><p>   可以实现数据库中所有的增删改查操作</p><ol><li><p>从数据库表中查询数据</p></li><li><p>从数据库表中插入新的数据</p></li><li><p>从数据库表中更新数据</p></li><li><p>从数据库表中删除数据</p></li><li><p>建表, 建库…</p></li></ol><h3 id="4、查询数据"><a href="#4、查询数据" class="headerlink" title="4、查询数据"></a>4、查询数据</h3><ol><li><p>从指定表中查出所有列的数据</p><p><code>SELECT * FROM 表名称</code></p></li><li><p>从指定表中查出指定列的数据</p><p><code>SELECT 列名称 FROM 表名称</code></p></li></ol><p>– 从users表中查询 username 和 status字段的数据<br><code>select username,status from users;</code></p><h3 id="5、插入语句"><a href="#5、插入语句" class="headerlink" title="5、插入语句"></a>5、插入语句</h3><p>向指定的数据表中插入一条数据</p><p>   <code>INSERT INTO 表名称(列1, 列2, ...) VALUES(值1, 值2, ...)</code></p><p>– 插入一条数据<br><code>insert into users (username,password) values(&#39;Tom4&#39;,&#39;456789&#39;);</code></p><p>   <strong>注意:</strong> 多个列和值之间使用逗号隔开, 列和值的顺序要保持一致</p><h3 id="6、更新数据语法"><a href="#6、更新数据语法" class="headerlink" title="6、更新数据语法"></a>6、更新数据语法</h3><p>更新数据表中的某一列或多列数据</p><p>   <code>UPDATE 表名称 SET 列1=值1, 列2=值2 WHERE 列名称=值;</code></p><p>– 将id为4的用户密码更新成 888888,状态码改为1<br> <code>update users set password=&#39;888888&#39;,status=1 where id=3;</code></p><p>  <strong>注意:</strong> SET 后多列数据更新使用逗号隔开, WHERE 后面跟的条件不能省略 </p><h3 id="7、删除数据语法"><a href="#7、删除数据语法" class="headerlink" title="7、删除数据语法"></a>7、删除数据语法</h3><p>   删除数据表中的某一行或多行数据</p><p>   <code>DELETE FROM 表名称 WHERE 列名称=值;</code></p><p>– 删除id为4的用户<br><code>delete from users where id=3;</code></p><h3 id="8、WHERE-子句的作用"><a href="#8、WHERE-子句的作用" class="headerlink" title="8、WHERE 子句的作用"></a>8、WHERE 子句的作用</h3><p>   如果需要有条件的从表中选取数据, 可以使用 WHERE 子句添加到 SQL 语句的末尾</p><p>  例如:  <code>SELECT * FROM 表名称 WHERE 列名称 运算符 值</code></p><p>– 查询id在5和10之间的数据，包含5和10<br><code>select * from users where id between 5 and 10;</code></p><p>– 查询username包含Tom的数据，%表示任意字符<br><code>select * from users where username like &#39;%Tom%&#39;;</code></p><h3 id="9、常见的运算符"><a href="#9、常见的运算符" class="headerlink" title="9、常见的运算符"></a>9、常见的运算符</h3><p>   (1) &gt; 和 &gt;= </p><p>   (2) &lt; 和 &lt;=</p><p>   (3) != 或 &lt;&gt;</p><p>   (4) =</p><p>   (5) BETWEEN</p><p>   (6) LIKE</p><h3 id="10、AND-和-OR-运算符"><a href="#10、AND-和-OR-运算符" class="headerlink" title="10、AND 和 OR 运算符"></a>10、AND 和 OR 运算符</h3><p>   可以在 WHERE 子句中把多个条件结合起来, AND 表示并且, OR 表示或者的意思</p><p>   – 查询表中status值为1并且id大于3的数据</p><p>​    <code>select * from users where status=1 and id&gt;3;</code></p><p>   – 查询表中status值为1或id大于6的数据</p><p>​    <code>select * from users where status=1 or id&gt;6;</code></p><h3 id="11、ORDER-BY-字句"><a href="#11、ORDER-BY-字句" class="headerlink" title="11、ORDER BY 字句"></a>11、ORDER BY 字句</h3><ol><li><p>使用 ORDER BY 子句对结果进行排序</p><p>   SELECT * FROM users ORDER BY status DESC;</p><p>   默认的排序方式为<strong>升序 ASC</strong>, 如果使用<strong>降序可以添加 DESC</strong> 关键字</p></li><li><p>多重排序规则</p><p>   <code>SELECT 列名称 FROM 表名称 ORDER BY 列名称 [排序规则], 列名称 [排序规则]</code></p><p>– 查询表中id值大于3的用户根据id降序排列(注意：where子句在前，order by子句在后)<br><code>select * from users where id&gt;3 order by id desc;</code></p></li><li><p>注意</p><p>   同时使用 ORDER BY 和 WHERE子句时, 应该让 ORDER BY 位于 WHERE 之后, 否则将会产生错误</p></li></ol><p>12、</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js（一）</title>
    <link href="/2021/02/21/Node.js%20%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <url>/2021/02/21/Node.js%20%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js-第一天"><a href="#Node-js-第一天" class="headerlink" title="Node.js 第一天"></a>Node.js 第一天</h1><h2 id="一、Node-js的相关概念"><a href="#一、Node-js的相关概念" class="headerlink" title="一、Node.js的相关概念"></a>一、Node.js的相关概念</h2><h3 id="1、什么是-Node-js-http-nodejs-cn"><a href="#1、什么是-Node-js-http-nodejs-cn" class="headerlink" title="1、什么是 Node.js [http://nodejs.cn/]"></a>1、什么是 Node.js [<a href="http://nodejs.cn/]">http://nodejs.cn/]</a></h3><p> Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境1</p><h3 id="2、Node-js-运行环境"><a href="#2、Node-js-运行环境" class="headerlink" title="2、Node.js 运行环境"></a>2、Node.js 运行环境</h3><p> 主要包含了 V8 解析引擎 和 内置的 API 接口</p><h3 id="3、注意："><a href="#3、注意：" class="headerlink" title="3、注意："></a>3、注意：</h3><ol><li><p>Node.js 中并不包含浏览器相关的 BOM 和 DOM 接口, 不能使用 document, window 这些对象</p></li><li><p>Node.js 是 Javascript 在后端的运行环境, 浏览器是 Javascript 在前端的运行环境</p></li></ol><h2 id="二、Node-js作用"><a href="#二、Node-js作用" class="headerlink" title="二、Node.js作用"></a>二、Node.js作用</h2><h3 id="1、Node-js-在前端中的应用"><a href="#1、Node-js-在前端中的应用" class="headerlink" title="1、Node.js 在前端中的应用"></a>1、Node.js 在前端中的应用</h3><ol><li><p>制作一些实用的命令行工具</p></li><li><p>基于 express 框架快速构建 Web 服务</p></li><li><p>基于 electron 框架构建桌面应用程序</p></li><li><p>基于 restify 框架构建 API 接口项目</p></li><li><p>微服务和中间件</p></li></ol><h3 id="2、Node-js-的主要特点"><a href="#2、Node-js-的主要特点" class="headerlink" title="2、Node.js 的主要特点"></a>2、Node.js 的主要特点</h3><ol><li><p>事件驱动编程</p></li><li><p>非阻塞异步 I/O 处理</p></li></ol><h3 id="3、Node-js-的学习方式"><a href="#3、Node-js-的学习方式" class="headerlink" title="3、Node.js 的学习方式"></a>3、Node.js 的学习方式</h3><p>学习的路径主要是： 内置 API 模块的使用 + 第三方 API 模块的使用</p><h2 id="三、Node-js安装"><a href="#三、Node-js安装" class="headerlink" title="三、Node.js安装"></a>三、Node.js安装</h2><p> 方式一：打开官网的安装页 (<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a>), 下载对应操作系统的安装包</p><p>   方式二：使用 nvm 命令安装不同版本的 Node 软件</p><ul><li><p>检测版本</p><p> 在终端执行 node -v / node –version 命令检查是否安装成功</p></li></ul><h2 id="四、在node中运行js文件"><a href="#四、在node中运行js文件" class="headerlink" title="四、在node中运行js文件"></a>四、在node中运行js文件</h2><h3 id="1、在-Node-中运行-js-文件的方法"><a href="#1、在-Node-中运行-js-文件的方法" class="headerlink" title="1、在 Node 中运行 js 文件的方法"></a>1、在 Node 中运行 js 文件的方法</h3><ol><li><p>打开 gitbash 终端或直接在vscode中拉起终端</p></li><li><p>执行命令 <code>node js的文件路径</code></p></li></ol><h3 id="2、了解终端中的常用快捷键"><a href="#2、了解终端中的常用快捷键" class="headerlink" title="2、了解终端中的常用快捷键"></a>2、了解终端中的常用快捷键</h3><p>   (1) 使用 ↑ 箭头可以直接返回上一条运行的命令</p><p>   (2) 使用 Tab 可以快速补全剩下的文件路径</p><p>   (3) 使用 CTRL + U 可以清空当前输入的命令</p><p>   (4) 使用 clear 可以清空可视区命令</p><p>   (5) 使用ctrl+左右箭头每次移动一个字节光标</p><h2 id="五、fs文件系统模块"><a href="#五、fs文件系统模块" class="headerlink" title="五、fs文件系统模块"></a>五、fs文件系统模块</h2><h3 id="1、读文件：-fs-readFile"><a href="#1、读文件：-fs-readFile" class="headerlink" title="1、读文件： fs.readFile()"></a>1、读文件： fs.readFile()</h3><p>fs.readFile(路径， 编码， 回调函数)</p><p><strong>注意：</strong>nodejs 的回调函数参数中，永远是“错误优先”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 引入模块： require(&#x27;模块名&#x27;)</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-comment">// 2. 调用方法来读取文件 </span><br>fs.readFile(<span class="hljs-string">&#x27;./hello.js&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, res</span>) =&gt;</span> &#123; <br>    <span class="hljs-built_in">console</span>.log(err);<br>    <span class="hljs-comment">// 读取成功err就为null</span><br>    <span class="hljs-comment">// res显示读取的文件内容代码</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---&#x27;</span>);<br>    <span class="hljs-comment">// res就是读取的文件</span><br>    <span class="hljs-built_in">console</span>.log(res);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="2、写文件：-fs-writeFile"><a href="#2、写文件：-fs-writeFile" class="headerlink" title="2、写文件： fs.writeFile()"></a>2、写文件： fs.writeFile()</h3><ul><li><p>writeFile(路径，写入的内容，回调函数)</p></li><li><p><strong>注意</strong>：如果不存在这个文件，会直接创建一个新的文件</p></li><li><p>写入的内容会直接覆盖原来的内容</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入fs模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-comment">// 调用方法向文件中写入内容</span><br>fs.writeFile(<span class="hljs-string">&#x27;D:/world123.txt&#x27;</span>, <span class="hljs-string">&#x27;hello 123&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 写入失败，err为错误对象</span><br>    <span class="hljs-comment">// 写入成功，err为null</span><br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`写入文件失败<span class="hljs-subst">$&#123;err.message&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log((<span class="hljs-string">&#x27;写入文件成功&#x27;</span>));<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="3、js文件的相对路径"><a href="#3、js文件的相对路径" class="headerlink" title="3、js文件的相对路径"></a>3、js文件的相对路径</h3><ol><li><p>Node 中的相对路径</p><p>   在 js 文件中的相对路径并不是相对自身文件所处目录, 而是相对当前执行 node 命令的所处目录 </p></li><li><p>总结</p><p> 在 Node.js 中使用完整的绝对路径代替不稳定的相对路径</p></li></ol><h3 id="4、内置变量：-dirname"><a href="#4、内置变量：-dirname" class="headerlink" title="4、内置变量：__dirname"></a>4、内置变量：__dirname</h3><p>每个js文件都内置了一个变量__dirname，它会返回当前文件的绝对路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用__dirname优化我们读取文件的路径</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br>fs.readFile(__dirname + <span class="hljs-string">&#x27;/hello.js&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`读取失败：<span class="hljs-subst">$&#123;err.message&#125;</span>`</span>);<br>    &#125;;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;读取成功&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="六、path路径模块"><a href="#六、path路径模块" class="headerlink" title="六、path路径模块"></a>六、path路径模块</h2><h3 id="1、多个路径片段进行组合：-path-join"><a href="#1、多个路径片段进行组合：-path-join" class="headerlink" title="1、多个路径片段进行组合： path.join()"></a>1、多个路径片段进行组合： path.join()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入path路径模块</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(path.join(<span class="hljs-string">&#x27;/a/b/c&#x27;</span>, <span class="hljs-string">&#x27;./d&#x27;</span>, <span class="hljs-string">&#x27;../f&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>)); <span class="hljs-comment">//  /a/b/c/f/e</span><br></code></pre></td></tr></table></figure><h3 id="2、获取路径中的文件名称：-path-basename"><a href="#2、获取路径中的文件名称：-path-basename" class="headerlink" title="2、获取路径中的文件名称： path.basename()"></a>2、获取路径中的文件名称： path.basename()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; basename &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-comment">// 调用方法 basename</span><br><span class="hljs-comment">// 返回值： 路径的最后一部分,如果添加了第二个参数，那么就直接返回文件名</span><br><span class="hljs-keyword">const</span> name = path.basename(<span class="hljs-string">&#x27;/c/d/e/123.txt&#x27;</span>, <span class="hljs-string">&#x27;.txt&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(name);<span class="hljs-comment">//123</span><br><br><span class="hljs-built_in">console</span>.log(path.basename(__dirname)); <span class="hljs-comment">// js</span><br></code></pre></td></tr></table></figure><h3 id="3、获取路径的拓展名"><a href="#3、获取路径的拓展名" class="headerlink" title="3、获取路径的拓展名"></a>3、获取路径的拓展名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-comment">// 调用方法：extname(&#x27;路径&#x27;)</span><br><span class="hljs-comment">// 返回值：返回路径最后一部分的拓展名（后缀名）</span><br><br><span class="hljs-built_in">console</span>.log(path.extname(<span class="hljs-string">&#x27;./A/B/C.json&#x27;</span>));<span class="hljs-comment">//.json</span><br><span class="hljs-keyword">const</span> filePath = path.join(__dirname, <span class="hljs-string">&#x27;world.txt&#x27;</span>);<br>fs.readFile(filePath, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 使用文件后缀判断文件类型</span><br>    <span class="hljs-keyword">if</span> (path.extname(filePath) == <span class="hljs-string">&#x27;.txt&#x27;</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;正在读取纯文本内容&#x27;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (path.extname(filePath) == <span class="hljs-string">&#x27;js&#x27;</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;正在读取js脚本内容&#x27;</span>);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js（三）</title>
    <link href="/2021/02/21/Node.js%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
    <url>/2021/02/21/Node.js%E7%AC%AC%E4%B8%89%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js第三天"><a href="#Node-js第三天" class="headerlink" title="Node.js第三天"></a>Node.js第三天</h1><h2 id="一、包"><a href="#一、包" class="headerlink" title="一、包"></a>一、包</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p> 带有一个 package.json 文件的目录称为包, 用来描述多个模块之间互相依赖的关系, 通常第三方模块都是以一个</p><p>  包的形式存在, 又称为 “第三方包” </p><h3 id="2、包的来源"><a href="#2、包的来源" class="headerlink" title="2、包的来源"></a>2、包的来源</h3><p> 通常我们直接使用第三方个人或团队开发出来的软件包, 进行免费下载和使用</p><h3 id="3、包管理器—npm"><a href="#3、包管理器—npm" class="headerlink" title="3、包管理器—npm"></a>3、包管理器—npm</h3><p> 世界上有众多的第三方模块或包, Node.js 中使用了一款 npm 包管理器来管理所有的第三方包</p><ol><li><p>尝试在 npm 网站上搜索你想要的包：<a href="https://www.npmjs.com/">https://www.npmjs.com/</a></p></li><li><p> 在 npm 上下载包： <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></p></li></ol><h3 id="4、npm-node-package-manage"><a href="#4、npm-node-package-manage" class="headerlink" title="4、npm (node package manage)"></a>4、npm (node package manage)</h3><p>下载, 更新, 卸载项目中的第三方包, 可以执行 npm -v 查看在自己电脑本机的 npm </p><h2 id="二、npm管理命令"><a href="#二、npm管理命令" class="headerlink" title="二、npm管理命令"></a>二、npm管理命令</h2><h3 id="1、下载一个指定的包-★"><a href="#1、下载一个指定的包-★" class="headerlink" title="1、下载一个指定的包 ★"></a>1、下载一个指定的包 ★</h3><p>   <code>npm i 包的具体名称</code> </p><h3 id="2、查看一个指定包★"><a href="#2、查看一个指定包★" class="headerlink" title="2、查看一个指定包★"></a>2、查看一个指定包★</h3><p>   <code>npm view 包的具体名称</code></p><h3 id="3、下载指定版本的包★"><a href="#3、下载指定版本的包★" class="headerlink" title="3、下载指定版本的包★"></a>3、下载指定版本的包★</h3><p>   <code>npm i 包的具体名称@版本号</code></p><h3 id="4、当我们在本地安装一个包后-会多出两个文件"><a href="#4、当我们在本地安装一个包后-会多出两个文件" class="headerlink" title="4、当我们在本地安装一个包后, 会多出两个文件:"></a>4、当我们在本地安装一个包后, 会多出两个文件:</h3><p>​    <strong>node_modules</strong> 和 <strong>package-lock.json</strong> </p><ol><li><p>node_modules 文件夹处在项目的根目录下, 用于存放安装的包</p></li><li><p>package-lock.json 是程序包的锁文件, 里面详细记录了每个包的版本信息和依赖模块, 不需要我们手动编写</p></li></ol><ul><li> 注意: </li></ul><ol><li><p>/node_modules/.bin 这个文件夹, 专门用来存放可执行文件</p></li><li><p>package-lock.json 文件可以确保不同开发人员之间的下载的包版本保持一致, 减少版本错乱的风险</p></li></ol><h3 id="5、包管理配置文件"><a href="#5、包管理配置文件" class="headerlink" title="5、包管理配置文件"></a>5、包管理配置文件</h3><p>  任何一个 npm 包必须具有 package.json 这样一个 JSON 格式的配置文件, 里面详细记录了<strong>包的名称，版本以及所依赖的其他包信息</strong></p><h3 id="6、开发环境和部署环境"><a href="#6、开发环境和部署环境" class="headerlink" title="6、开发环境和部署环境"></a>6、开发环境和部署环境</h3><p>   <strong>开发环境：</strong>又叫本地环境, 只对开发者本身提供服务, 要求比较随意, 错误调试都可以打开为了更方便的检测程序;</p><p>   <strong>部署环境：</strong>又叫线上环境 或 生产环境, 正式对外进行提供服务; 要确保功能完备, 用户体验友好</p><p>  <strong>注意：</strong></p><p>   通常在我们的项目根目录下也会使用 package.json 这个文件来记录项目的详细信息</p><h3 id="7、多人协作开发问题"><a href="#7、多人协作开发问题" class="headerlink" title="7、多人协作开发问题"></a>7、多人协作开发问题</h3><p>多人合作一个项目时，第三方的包太多体积过大，node_modules 这个文件夹不易于团队成员之间进行共享，</p><p> 使用包管理配置文件来记录项目中所依赖的其他第三方包，这样团队成员之间只需要共享这个配置文件就可以了</p><p>  <strong>注意</strong>：node_modules 这个文件夹需要添加到 .gitignore 忽略文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs .gitignore">#定义git忽略文件<br>node_modules&#x2F;<br></code></pre></td></tr></table></figure><h3 id="8、快速创建包管理配置文件★"><a href="#8、快速创建包管理配置文件★" class="headerlink" title="8、快速创建包管理配置文件★"></a>8、快速创建包管理配置文件★</h3><p>在项目的根目录下执行 <code>npm init -y</code> 命令</p><p>  注意：</p><ol><li><p>项目目录不能使用中文命名, 不能包含空格</p></li><li><p>创建了 package.json 文件后, 每次安装包的名称和版本都会记录在这个文件中，不需要手动修改</p></li></ol><h3 id="9、dependencies配置项的作用"><a href="#9、dependencies配置项的作用" class="headerlink" title="9、dependencies配置项的作用"></a>9、dependencies配置项的作用</h3><p>package.json 配置文件中有两个关键的配置项:</p><ul><li>dependencies: 在生产环境中所需要的软件包</li><li>devDependencies: 仅本地开发和测试所需要的软件包</li></ul><p>上述配置项的作用：</p><p>​    其他项目成员在执行 <code>npm install</code> 命令时，会自动根据 package.json 文件中记录的包名称和版本信息全部进行下载</p><h3 id="10、卸载指定的包-★"><a href="#10、卸载指定的包-★" class="headerlink" title="10、卸载指定的包 ★"></a>10、卸载指定的包 ★</h3><p> 执行 <code>npm uninstall 包名称</code></p><p> <strong>注意：</strong></p><ol><li><p>当命令执行成功后，dependencies 配置项下的包会自动移除</p></li><li><p>卸载包的时候不需要指定版本号</p></li></ol><h3 id="11、devDependencies-配置作用-★"><a href="#11、devDependencies-配置作用-★" class="headerlink" title="11、devDependencies 配置作用 ★"></a>11、devDependencies 配置作用 ★</h3><ul><li><p>作用：</p><p>只在本地开发测试阶段需要用到的包，一般记录在 devDependencies 配置项中，后期在进行项目打包上线的时候，并不会把这些包携带到线上环境</p></li><li><p>如何安装开发测试阶段用到的包</p><p>执行命令 <code>npm i --save-dev 包名称@版本号</code> </p><p>或 <code>npm i -D 包名称@版本号</code></p></li></ul><h3 id="12、解决包下载速度的问题★"><a href="#12、解决包下载速度的问题★" class="headerlink" title="12、解决包下载速度的问题★"></a>12、解决包下载速度的问题★</h3><ol><li><p>npm 下载包的问题 </p><p>当我们下载国外服务器上的包时，网速较慢容易下载失败， 可以考虑把下载包的服务器（源）进行更换</p></li><li><p>更换国内的源</p><ul><li><p>在任意目录下执行： <code>npm config set registry=https://registry.npm.taobao.org</code></p></li><li><p>检查源有没有更换成功： <code>npm config get registry</code></p></li></ul></li><li><p>补充：借助 cnpm 包，提供了下载命令 <code>cnpm i 包名称</code></p><p> 安装：<code>npm i cnpm -g</code></p><p> 注意：如果npm下载包可以正常下载时，尽量少用cnpm下载包命令</p></li></ol><h3 id="13、包的分类"><a href="#13、包的分类" class="headerlink" title="13、包的分类"></a>13、包的分类</h3><ol><li><p>npm 的包从作用域上可以分为： </p><ul><li><p>项目包： 被安装到项目的 node_modules 目录中的包，只能在当前项目下进行使用</p><p>   - [核心依赖包] 线上环境用到的依赖包： npm i 包名称</p><p>   - [开发依赖包] 开发测试环境用到的依赖包：npm i -D 包名称</p></li><li><p>全局包： 被下载到 node 安装位置 node_modules 目录下的包，可以在全局范围(任意目录)内使用</p><p>   安装命令： npm i -g 包名称</p><p>   卸载命令： npm uninstall -g 包名称</p></li></ul></li><li><p>注意: 具有全局工具性的包才有全局安装的必要性, 可以参考 npm 官网中对包的说明</p></li></ol><h3 id="14、全局包的使用★"><a href="#14、全局包的使用★" class="headerlink" title="14、全局包的使用★"></a>14、全局包的使用★</h3><p>使用一个把 markdown 格式的文档转成 html 格式文件的工具包</p><ol><li><p>安装全局包： npm i -g i5ting_toc </p></li><li><p>使用全局命令： <code>i5ting_toc -f 要转换的md文件 index.html</code></p></li></ol><p>可以在此文件夹中查看已经转换的html文件</p><h3 id="15、包的规范结构"><a href="#15、包的规范结构" class="headerlink" title="15、包的规范结构"></a>15、包的规范结构</h3><p> 一个包规范的组成结构： </p><ol><li><p>必须以单独的目录存在</p></li><li><p>包的根目录下必须包含 package.json 配置文件</p></li><li><p>package.json 这个配置文件必须包含 name, version, main 三个属性, 分别代表包的名称，版本和包的入口</p></li></ol><p>  <strong>注意：</strong></p><p>   main 配置包的主入口文件，我们在使用 require(‘foo’) 引入一个包时，返回的是 foo 这个包主入口文件导出的对象</p><h2 id="三、开发一个自己的包"><a href="#三、开发一个自己的包" class="headerlink" title="三、开发一个自己的包"></a>三、开发一个自己的包</h2><h3 id="1、开发自己的包"><a href="#1、开发自己的包" class="headerlink" title="1、开发自己的包"></a>1、开发自己的包</h3><ul><li>创建一个文件夹保存自己的开发的包</li><li>要包含文件：<ul><li><code>package.json</code>：存放包的相关信息</li><li><code>index.js</code>：包的入口文件</li><li><code>README.md</code>：使用文档</li></ul></li></ul><h3 id="2、发布包的步骤★"><a href="#2、发布包的步骤★" class="headerlink" title="2、发布包的步骤★"></a>2、发布包的步骤★</h3><ol><li><p>编写包的说明文档 </p><p>在包的根目录下添加文件 README.md 文件</p></li><li><p>注册一个 npm 账号</p><p>打开注册网址: <a href="https://www.npmjs.com/signup">https://www.npmjs.com/signup</a></p></li><li><p>pc端打开注册邮箱进行确认</p><p>点击蓝色按钮 Verify Email</p></li><li><p>在包的发布目录下面执行命令</p><p><code>npm publish</code></p></li><li><p>删除已经发布的包</p><p><code>npm unpublish 包名称 --force</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js（二）</title>
    <link href="/2021/02/21/Node.js%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
    <url>/2021/02/21/Node.js%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js第二天"><a href="#Node-js第二天" class="headerlink" title="Node.js第二天"></a>Node.js第二天</h1><h2 id="一、http模块介绍"><a href="#一、http模块介绍" class="headerlink" title="一、http模块介绍"></a>一、http模块介绍</h2><h3 id="1、服务器和客户端的概念回顾"><a href="#1、服务器和客户端的概念回顾" class="headerlink" title="1、服务器和客户端的概念回顾"></a>1、服务器和客户端的概念回顾</h3><p>​    客户端负责向服务器发送请求, 获取数据并进行使用; </p><p>   服务器负责接收来自客户端的网络请求, 处理数据并进行返回</p><h3 id="2、http-内置模块"><a href="#2、http-内置模块" class="headerlink" title="2、http 内置模块"></a>2、http 内置模块</h3><p>提供了创建 Web 服务器和客户端的相关 API</p><h3 id="3、使用-Node-创建服务器的优势"><a href="#3、使用-Node-创建服务器的优势" class="headerlink" title="3、使用 Node 创建服务器的优势"></a>3、使用 Node 创建服务器的优势</h3><p>无需安装和配置复杂的后台环境, 只需要几行代码就可以开启一个服务器, 十分精巧</p><h2 id="二、服务器相关概念"><a href="#二、服务器相关概念" class="headerlink" title="二、服务器相关概念"></a>二、服务器相关概念</h2><h3 id="1、IP-地址"><a href="#1、IP-地址" class="headerlink" title="1、IP 地址"></a>1、IP 地址</h3><p>   用来标识互联网上一台计算机的唯一地址编号, 只有访问正确的 IP 地址才能和计算机进行数据通信</p><h3 id="2、IP-地址格式"><a href="#2、IP-地址格式" class="headerlink" title="2、IP 地址格式"></a>2、IP 地址格式</h3><p>   采用 “点分十进制” 表示成 A.B.C.D 的形式, 就是用4个从0~255的数字，来表示一个IP地址, 比如：</p><p>  我们在终端输入 <code>ipconfig</code> 可以查看本机的 IPv4 地址格式</p><h3 id="3、了解-ping-命令"><a href="#3、了解-ping-命令" class="headerlink" title="3、了解 ping 命令"></a>3、了解 ping 命令</h3><p>   在终端执行 <code>ping 域名</code>, 可以获取当前域名的 IP 地址并测试出网络连接情况</p><h2 id="三、域名和域名服务器"><a href="#三、域名和域名服务器" class="headerlink" title="三、域名和域名服务器"></a>三、域名和域名服务器</h2><h3 id="1、域名-和-IP地址"><a href="#1、域名-和-IP地址" class="headerlink" title="1、域名 和 IP地址"></a>1、域名 和 IP地址</h3><p>   域名和 IP 地址是一一对应的关系, 它是 IP 地址字符型的表达, 这种映射关系被存放在一台 DNS 服务器上</p><h3 id="2、DNS（Domain-Name-System）"><a href="#2、DNS（Domain-Name-System）" class="headerlink" title="2、DNS（Domain Name System）"></a>2、DNS（Domain Name System）</h3><p>   专门用来管理互联网上域名和 IP 对应关系的公网服务器</p><h3 id="3、本地计算机的-IP-和-域名"><a href="#3、本地计算机的-IP-和-域名" class="headerlink" title="3、本地计算机的 IP 和 域名"></a>3、本地计算机的 IP 和 域名</h3><p>   开发测试时, 本地计算机 IP 一般是 127.0.0.1, 对应的域名是 localhost, 没有使用区别</p><h2 id="四、端口"><a href="#四、端口" class="headerlink" title="四、端口"></a>四、端口</h2><h3 id="1、端口的概念"><a href="#1、端口的概念" class="headerlink" title="1、端口的概念"></a>1、端口的概念</h3><p>   IP 地址可以用来标识唯一的计算机地址, 但是计算机上运行的不同服务无法仅用 IP 来标识, 于是使用了</p><p>  IP + 端口号的方式来区分不同的服务, 每个服务都对应着一个唯一的端口号</p><h3 id="2、端口的作用"><a href="#2、端口的作用" class="headerlink" title="2、端口的作用"></a>2、端口的作用</h3><p>   客户端发送的请求, 通过指定的端口号, 可以把请求交给对应的服务来进行处理</p><p>  注意： </p><p>   ULR 中的端口号如果是 80, 一般可以省略</p><h2 id="五、创建服务器步骤"><a href="#五、创建服务器步骤" class="headerlink" title="五、创建服务器步骤"></a>五、创建服务器步骤</h2><ol><li><p>引入 http 模块 </p></li><li><p>创建服务实例</p></li><li><p>绑定事件, 监听请求</p></li><li><p>监听端口, 启动服务</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入http模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;有人访问服务器&#x27;</span>);<br>&#125;).listen(<span class="hljs-number">3006</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server running at http://127.0.0.1:3006&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="六、请求对象和响应对象"><a href="#六、请求对象和响应对象" class="headerlink" title="六、请求对象和响应对象"></a>六、请求对象和响应对象</h2><p>Node 服务器接收到了客户端的请求, 就会调用给服务器绑定的 request 请求事件处理函数, 函数的第一个参数</p><p> 是 Node 封装好的请求对象, 第二个参数是响应对象 </p><h3 id="1、requset-请求对象"><a href="#1、requset-请求对象" class="headerlink" title="1、requset 请求对象"></a>1、requset 请求对象</h3><p>   提供了获取客户端相关的请求属性, 比如: </p><p>   - req.url 请求的路径</p><p>   - req.method 请求的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><br><span class="hljs-comment">// 创建服务实例createServer()</span><br><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`当前的请求路径为<span class="hljs-subst">$&#123;req.url&#125;</span>,请求方式是<span class="hljs-subst">$&#123;req.method&#125;</span>`</span>);<br>&#125;)<br><br><span class="hljs-comment">// 监听端口，开启服务</span><br>server.listen(<span class="hljs-number">3006</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;开启服务成功，请访问:http://localhost:3006&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="2、response-响应对象"><a href="#2、response-响应对象" class="headerlink" title="2、response 响应对象"></a>2、response 响应对象</h3><p>   提供了服务器响应数据相关的方法, 比如：</p><p>   - res.setHeader() 设置响应头</p><p>   - res.end() 响应数据内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><br><span class="hljs-comment">// 定义计数器</span><br><span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// res提供了服务端响应数据的方法</span><br>    <span class="hljs-comment">// 1.响应数据给客户端 2.直接终止当前的请求</span><br>    <span class="hljs-keyword">if</span> (req.url !== <span class="hljs-string">&#x27;/favicon.ico&#x27;</span>) &#123;<br><br>        <span class="hljs-comment">// 设置一个响应头，指定文件类型和编码方式</span><br>        res.setHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html;charset=utf-8&#x27;</span>)<br>        res.end(<span class="hljs-string">`&lt;h3&gt;hello 你是第<span class="hljs-subst">$&#123;++num&#125;</span>位访问者!&lt;/h3&gt;`</span>);<br>        <span class="hljs-comment">// console.log(123);</span><br>    &#125;<br>    <span class="hljs-comment">// res.end()不会终止后续代码的运行，但请求已终止</span><br>&#125;)<br><span class="hljs-comment">// 监听端口，开启服务</span><br>server.listen(<span class="hljs-number">3006</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;开启服务成功，地址:http://localhost:3006&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="七、模块化"><a href="#七、模块化" class="headerlink" title="七、模块化"></a>七、模块化</h2><h3 id="1、什么是模块化"><a href="#1、什么是模块化" class="headerlink" title="1、什么是模块化"></a>1、什么是模块化</h3><p>   把一个大的功能需求拆分成若干功能项的小模块, 每个模块可组合, 分解和更换, 这就是模块化思想</p><h3 id="2、Node-js-中的模块化"><a href="#2、Node-js-中的模块化" class="headerlink" title="2、Node.js 中的模块化"></a>2、Node.js 中的模块化</h3><p>   把一个大的文件拆分成多个互相依赖的小文件, 每个文件就是一个模块</p><h3 id="3、好处"><a href="#3、好处" class="headerlink" title="3、好处"></a>3、好处</h3><ol><li>提高复用性 2. 代码可维护 3. 可以按需加载</li></ol><h3 id="4、模块化规范"><a href="#4、模块化规范" class="headerlink" title="4、模块化规范"></a>4、模块化规范</h3><p>模块在进行拆分和组合时需要遵守的规则, 主要考虑以下两点：</p><ol><li><p> <strong>如何把自身模块成员向外暴露</strong></p></li><li><p> <strong>如何把其他模块进行引入</strong></p></li></ol><h3 id="5、Node-js中的模块分类"><a href="#5、Node-js中的模块分类" class="headerlink" title="5、Node.js中的模块分类"></a>5、Node.js中的模块分类</h3><ol><li><p>内置模块 （由 Node.js 官方提供的, 例如 fs, path, http 等）</p></li><li><p>自定义模块 （自己创建的 js 文件）</p></li><li><p>第三方模块 （由第三方开发的模块, 使用前需要先下载）</p></li></ol><h3 id="6、加载模块"><a href="#6、加载模块" class="headerlink" title="6、加载模块"></a>6、加载模块</h3><p>​        require() 方法</p><p>  <strong>注意：</strong> </p><p>​    加载内置模块和第三方模块，都是直接传入模块名，加载自己的模块需要传入文件路径，并省略 .js 后缀</p><h3 id="7、模块作用域"><a href="#7、模块作用域" class="headerlink" title="7、模块作用域"></a>7、模块作用域</h3><p>不同模块中定义的方法和变量，只能在当前模块内访问，这种模块级别的限制叫做模块作用域</p><ul><li><p>其他作用域</p><p>   局部作用域</p><p>   全局作用域</p><p>   块级作用域；使用let, const</p></li></ul><h3 id="8、module和exports"><a href="#8、module和exports" class="headerlink" title="8、module和exports"></a>8、module和exports</h3><p><strong>exports:{ } 默认为空对象</strong></p><ol><li><p>module 对象的作用</p><p>在每个模块中， module 这个内置的变量表示当前模块的引用</p></li><li><p>module.exports 对象作用</p><p>把模块中的成员导出给外部, 供外界进行加载和调用</p></li><li><p>exports 对象</p><p>exports 是 module.exports 的更简短的引用形式</p></li></ol><p>  <strong>注意：</strong></p><p>   (1) module.exports 的值就是当前模块最终导出的结果</p><p>   (2) 可以通过 exports 访问和修改 module.exports 上的属性, 但不能通过赋值方式进行覆盖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">module</span>.exports === &#123;&#125;); <span class="hljs-comment">//false 复杂数据类型比较的是地址值</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">module</span>.exports === <span class="hljs-built_in">exports</span>); <span class="hljs-comment">//true</span><br><br><span class="hljs-built_in">exports</span> = &#123;<br>    name: <span class="hljs-string">&#x27;xh&#x27;</span>,<br>    age: <span class="hljs-number">12</span><br>&#125;<br><span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">exports</span>;<br><span class="hljs-built_in">exports</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">params</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>);<br>&#125;<br><span class="hljs-built_in">module</span>.exports.sing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">params</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">456</span>);<br>&#125;;<br><span class="hljs-comment">//打印结果：&#123;</span><br><span class="hljs-comment">// name: &#x27;xh&#x27;,</span><br><span class="hljs-comment">//     age: 12,</span><br><span class="hljs-comment">//     say: [Function(anonymous)],</span><br><span class="hljs-comment">//     sing: [Function(anonymous)]</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 原因：指向相同的地址</span><br></code></pre></td></tr></table></figure><p>  <strong>总结：</strong></p><p>   (1) 尽量避免 exports 对象重新赋值，添加一个导出成员 exports.xx=xx,</p><p>   (2) 声明新对象，使用module.exports={ xxx };</p><h2 id="八、CommonJS规范"><a href="#八、CommonJS规范" class="headerlink" title="八、CommonJS规范"></a>八、CommonJS规范</h2><p>Node.js 中的模块化遵循 CommonJS (cjs) 规范，它规定了模块的特性和依赖方式：</p><ol><li><p>每个模块内部, module 变量代表当前模块</p></li><li><p>module 变量是一个对象, module.exports 属性是对外暴露的接口</p></li><li><p>加载某个模块, 就是加载该模块的 module.exports 属性, require() 是加载的方法</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js模块加载机制</title>
    <link href="/2021/02/21/%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/02/21/%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h1><h3 id="1、模块优先从缓存中进行加载"><a href="#1、模块优先从缓存中进行加载" class="headerlink" title="1、模块优先从缓存中进行加载"></a>1、模块优先从缓存中进行加载</h3><p> 模块在第一次加载后会被缓存, 如果每次调用 require(‘foo’) 都解析到同一文件，则返回相同的对象,不会导致模块的代码被执行多次</p><ul><li><p>缓存的作用</p><p>不论是 node.js 内置的核心模块，用户自定义的模块还是第三方模块，都有对应的缓存策略，提升模块的加载效率</p><p> 说明：文档地址（<a href="http://nodejs.cn/api/modules.html#modules_caching%EF%BC%89">http://nodejs.cn/api/modules.html#modules_caching）</a> </p></li></ul><h3 id="2、内置模块的加载机制"><a href="#2、内置模块的加载机制" class="headerlink" title="2、内置模块的加载机制"></a>2、内置模块的加载机制</h3><p>require() 总是会优先加载核心模块, 比如 require(‘http’) 始终返回内置的 HTTP 模块，即使有同名文件</p><h3 id="3、自定义模块的加载机制"><a href="#3、自定义模块的加载机制" class="headerlink" title="3、自定义模块的加载机制"></a>3、自定义模块的加载机制</h3><p>​    使用 require() 方法去加载自定义模块，必须指定 ‘/‘、 ‘./‘ 或 ‘../‘ 开头的路径，如果没有这个路径标识，node 会默认把它当作是一个核心模块或来自 node_modules 目录下的第三方模块</p><ul><li><p>自定义文件模块</p><p>如果按确切的文件名没有找到模块，则 Node.js 会尝试带上 .js、 .json 或 .node 拓展名再加载</p></li><li><p>自定义目录模块</p><p>当传递一个目录标识符给 require () 方法时, 加载的顺序如下:</p></li></ul><ol><li><p>在加载的目录下查找 package.json 的文件, 并寻找 main 属性作为 require 的入口</p></li><li><p>上述找不到, Node.js 将会试图加载目录下的 index.js 或 index.node 文件</p></li></ol><h3 id="4、第三方模块的加载机制"><a href="#4、第三方模块的加载机制" class="headerlink" title="4、第三方模块的加载机制"></a>4、第三方模块的加载机制</h3><pre><code> 如果传递给 require() 的模块标识符不是一个核心模块，也没有以 &#39;/&#39; 、 &#39;../&#39; 或 &#39;./&#39; 开头，</code></pre><p>​     那么 Node.js 会从当前模块的父目录开始，尝试从它的 /node_modules 目录里加载模块。如果还是没有找到，</p><p>​    则移动到再上一层父目录，直到文件系统的根目录。</p>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax第一天</title>
    <link href="/2021/02/04/Ajax%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <url>/2021/02/04/Ajax%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax第一天"><a href="#Ajax第一天" class="headerlink" title="Ajax第一天"></a>Ajax第一天</h1><h2 id="一、客户端与服务器"><a href="#一、客户端与服务器" class="headerlink" title="一、客户端与服务器"></a>一、客户端与服务器</h2><h3 id="1、上网的目的"><a href="#1、上网的目的" class="headerlink" title="1、上网的目的"></a>1、上网的目的</h3><p>通过互联网的形式来 <strong>获取和消费资源</strong></p><h3 id="2、服务器"><a href="#2、服务器" class="headerlink" title="2、服务器"></a>2、服务器</h3><p>上网过程中，负责 <strong>存放和对外提供资源</strong> 的电脑，叫做服务器</p><h3 id="3、客户端"><a href="#3、客户端" class="headerlink" title="3、客户端"></a>3、客户端</h3><p>在上网过程中，负责 <strong>获取和消费资源</strong> 的电脑，叫做客户端</p><h2 id="二、URL地址的概念-amp-组成"><a href="#二、URL地址的概念-amp-组成" class="headerlink" title="二、URL地址的概念&amp;组成"></a>二、URL地址的概念&amp;组成</h2><h3 id="1、URL的概念"><a href="#1、URL的概念" class="headerlink" title="1、URL的概念"></a>1、URL的概念</h3><p>URL（全称是 <code>UniformResourceLocator</code>） 中文叫 <strong>统一资源定位符</strong>，用于标识互联网上每个资源的唯一存放位置。浏览器只有通过URL地址，才能正确定位资源的存放位置，从而成功访问到对应的资源</p><h3 id="2、URL的组成"><a href="#2、URL的组成" class="headerlink" title="2、URL的组成"></a>2、URL的组成</h3><p><img src="E:\黑马培训\前端基础\案例练习\就业班\笔记\ajax\Ajax第一天\images\URL组成.png" alt="URL组成"></p><h3 id="3、复习"><a href="#3、复习" class="headerlink" title="3、复习"></a>3、复习</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">url路径的获取：location.path (<span class="hljs-regexp">/home/i</span>ndex.html)<br><br>  url中的查询参数：location.search (?uname=tom&amp;age=<span class="hljs-number">20</span>)<br><br>  url中的锚点：location.hash (#abc)<br><br></code></pre></td></tr></table></figure><p>   BOM中的三大对象：location（操作地址栏） history（浏览器历史） Navigation(获取浏览器对象)</p><h2 id="三、客户端与服务器通讯过程"><a href="#三、客户端与服务器通讯过程" class="headerlink" title="三、客户端与服务器通讯过程"></a>三、客户端与服务器通讯过程</h2><p><img src="E:\黑马培训\前端基础\案例练习\就业班\笔记\ajax\Ajax第一天\images\客户端与服务器通讯过程.png" alt="客户端与服务器通讯过程"></p><ul><li>客户端与服务器之间的通讯过程，分为： <strong>请求-处理-响应</strong> 三个步骤</li><li>网页中每一个资源，都是通过 <strong>请求-处理-响应</strong> 的方式从服务器获取回来的</li></ul><h2 id="四、服务器对外提供的资源"><a href="#四、服务器对外提供的资源" class="headerlink" title="四、服务器对外提供的资源"></a>四、服务器对外提供的资源</h2><h3 id="1、常见资源"><a href="#1、常见资源" class="headerlink" title="1、常见资源"></a>1、常见资源</h3><p>文档、图片、音频、视频</p><h3 id="2、数据也是资源"><a href="#2、数据也是资源" class="headerlink" title="2、数据也是资源"></a>2、数据也是资源</h3><p><strong>网页中的数据，也是服务器对外提供的一种资源</strong>，例如股票数据，各行业排行榜等</p><h3 id="3、资源的请求方式"><a href="#3、资源的请求方式" class="headerlink" title="3、资源的请求方式"></a>3、资源的请求方式</h3><ol><li><p>GET请求: 表示<strong>向服务器获取数据</strong>, 例如: 获取页面, 图片, js文件, 数据…</p></li><li><p>POST请求: 表示<strong>向服务器发送数据</strong>, 例如: 登录或注册个人信息, 购买商品, 发表文章…. </p></li></ol><h2 id="五、Ajax概念"><a href="#五、Ajax概念" class="headerlink" title="五、Ajax概念"></a>五、Ajax概念</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>Asynchronous JavaScript And XML(全称不用记), 即使用 XMLHttpRequest 进行数据获取和提交的方式,</p><p>  它最大的特点就是<strong>异步(Async)</strong>, 可以在不重新刷新页面的情况下与服务器通信, 交换数据</p><h3 id="2、异步任务和同步任务回顾"><a href="#2、异步任务和同步任务回顾" class="headerlink" title="2、异步任务和同步任务回顾"></a>2、异步任务和同步任务回顾</h3><ul><li><p>异步任务: 图片,脚本资源加载; 点击事件; 定时器事件; ajax 数据交互</p></li><li><p>异步执行任务的好处: 不会阻塞主线程执行栈上的同步任务</p><p> 复习：一个回调函数就是一个异步任务，先执行同步再执行异步任务</p></li></ul><h3 id="3、jquery-中的-ajax"><a href="#3、jquery-中的-ajax" class="headerlink" title="3、jquery 中的 ajax"></a>3、jquery 中的 ajax</h3><p>使用 jQuery 为我们封装好的 XMLHttpRequest 方法, 可以提升开发的效率, 避免兼容性问题</p><h3 id="4、jquery-中-ajax-的请求方法"><a href="#4、jquery-中-ajax-的请求方法" class="headerlink" title="4、jquery 中 ajax 的请求方法"></a>4、jquery 中 ajax 的请求方法</h3><p>$.get()   用于发送 GET 请求，获取数据</p><p>$.post()  用于发送 POST 请求，提交数据</p><p>$.ajax({ })  用于发送任意 HTTP 请求，可以获取和提交数据</p><h3 id="5、get-和-post-请求的区别-面试-★★★"><a href="#5、get-和-post-请求的区别-面试-★★★" class="headerlink" title="5、get 和 post 请求的区别 (面试)★★★"></a>5、get 和 post 请求的区别 (面试)★★★</h3><ol><li><p>get 请求发送的参数放在 url 中, post 参数放在 请求体 中, 相对安全</p></li><li><p>get 请求会被缓存到浏览器, post 不会被缓存</p></li><li><p>get 请求的参数有长度限制, post 发送数据量比 get 大, 且支持发送二进制数据</p></li></ol><h2 id="六、jQuery中的Ajax"><a href="#六、jQuery中的Ajax" class="headerlink" title="六、jQuery中的Ajax"></a>六、<code>jQuery</code>中的Ajax</h2><h3 id="1、-get-函数介绍"><a href="#1、-get-函数介绍" class="headerlink" title="1、$.get() 函数介绍"></a>1、$.get() 函数介绍</h3><ul><li><p>$.get(url, [data], [callback])</p></li><li><p>参数说明： </p><p> (1) url: 请求地址必须传入</p><p> (2) data: 请求资源时的参数信息 (key/value格式)</p><p> (3) callback: 获取服务器数据成功时的回调函数</p></li></ul><p><img src="E:\黑马培训\前端基础\案例练习\就业班\笔记\ajax\Ajax第一天\images\get请求参数.png" alt="get请求参数"></p><h3 id="2、-post-函数介绍"><a href="#2、-post-函数介绍" class="headerlink" title="2、$.post() 函数介绍"></a>2、$.post() 函数介绍</h3><p>发送 post 请求语法: </p><ul><li><p>$.post(url, [data], [callback])</p></li><li><p>参数说明： </p><p> (1) url: 请求地址必须传入</p><p> (2) data: 请求资源时的参数信息(key/value格式)</p><p> (3) callback: 请求服务器数据成功时的回调函数</p></li></ul><p><img src="E:\黑马培训\前端基础\案例练习\就业班\笔记\ajax\Ajax第一天\images\post请求参数.png" alt="post请求参数"></p><h3 id="3、-ajax-函数介绍"><a href="#3、-ajax-函数介绍" class="headerlink" title="3、$.ajax() 函数介绍"></a>3、<code>$.ajax()</code> 函数介绍</h3><ul><li><code>$.ajax()</code> 函数的基本语法如下：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">$.ajax(&#123;<br>       url:  请求地址,<br>       method: 请求方式,<br>       data: 请求参数,<br>       success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123; <span class="hljs-comment">// 请求成功的回调函数 &#125;</span><br>     &#125;)<br></code></pre></td></tr></table></figure><ul><li>注意: 从jquery 1.9 版本开始往后, 请求类型的参数名推荐使用 method</li></ul><h3 id="4、-ajax-发起-get-请求"><a href="#4、-ajax-发起-get-请求" class="headerlink" title="4、$.ajax() 发起 get 请求"></a>4、<code>$.ajax()</code> 发起 get 请求</h3><p>使用 <code>$.ajax()</code> 发起 <code>GET</code> 请求时，只需要将 <code>type</code> 属性 的值设置为 ‘<code>GET</code>’ 即可：</p><p><img src="E:\黑马培训\前端基础\案例练习\就业班\笔记\ajax\Ajax第一天\images\Ajax调用get方法.png" alt="Ajax调用get方法"></p><h3 id="5、-ajax-发起-post-请求"><a href="#5、-ajax-发起-post-请求" class="headerlink" title="5、$.ajax 发起 post 请求"></a>5、<code>$.ajax</code> 发起 post 请求</h3><p>使用 <code>$.ajax()</code> 发起 <code>post</code>请求，只需要把 <code>type</code>属性的值 设置为 ‘<code>post</code>’ 即可：</p><p><img src="E:\黑马培训\前端基础\案例练习\就业班\笔记\ajax\Ajax第一天\images\Ajax调用post方法.png" alt="Ajax调用post方法"></p><h2 id="七、接口"><a href="#七、接口" class="headerlink" title="七、接口"></a>七、接口</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>发送 ajax 请求时的 URL 地址, 叫做数据接口; 每个接口必须有自己的请求类型</p><h3 id="2、接口文档"><a href="#2、接口文档" class="headerlink" title="2、接口文档"></a>2、接口文档</h3><p> 项目接口的说明文档, 它是我们调用接口的依据. 前端人员根据接口文档中规定的 url 地址，请求参数等进行调用，</p><p>  后端人员负责维护接口返回的数据</p><h3 id="3、接口规范"><a href="#3、接口规范" class="headerlink" title="3、接口规范"></a>3、接口规范</h3><p>一个规范的接口文档通常包含下列 5 部分：</p><ol><li><p>接口名称: 说明接口功能</p></li><li><p>接口的 URL 地址</p></li><li><p>接口的请求方式: get, post</p></li><li><p>接口的请求参数格式: 参数名称, 参数类型, 参数是否必选, 含义说明</p></li><li><p>接口的响应的详细描述: 返回的数据名称, 数据类型, 含义说明</p></li><li><p>接口的返回示例</p></li></ol><p>注意：以上为理想状态下，一般就一个地址QAQ！</p>]]></content>
    
    
    <categories>
      
      <category>Ajax学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax学习</title>
    <link href="/2021/02/04/Ajax%E7%AC%AC%E5%9B%9B%E5%A4%A9/"/>
    <url>/2021/02/04/Ajax%E7%AC%AC%E5%9B%9B%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax第四天"><a href="#Ajax第四天" class="headerlink" title="Ajax第四天"></a>Ajax第四天</h1><h2 id="一、同源策略"><a href="#一、同源策略" class="headerlink" title="一、同源策略"></a>一、同源策略</h2><h3 id="1、同源定义"><a href="#1、同源定义" class="headerlink" title="1、同源定义"></a>1、同源定义</h3><p>如果两个页面的协议，域名和端口都相同，则两个页面具有<strong>相同的源</strong>。</p><h3 id="2、同源策略定义"><a href="#2、同源策略定义" class="headerlink" title="2、同源策略定义"></a>2、同源策略定义</h3><p><strong>同源策略</strong>（英文全称 Same origin policy）是<strong>浏览器</strong>提供的一个<strong>安全功能</strong></p><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。</p><p>它用于限制一个网站和另一个非同源网站进行资源交互, 增强了网站的安全性, 避免了被攻击的风险</p><h3 id="3、同源策略限制了哪些交互"><a href="#3、同源策略限制了哪些交互" class="headerlink" title="3、同源策略限制了哪些交互"></a>3、同源策略限制了哪些交互</h3><ol><li><p>无法读取非同源网站的 localStorage, cookie</p></li><li><p>无法访问非同源网站的 DOM</p></li><li><p>无法向非同源网站发送 Ajax 请求</p></li></ol><h2 id="二、跨域"><a href="#二、跨域" class="headerlink" title="二、跨域"></a>二、跨域</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p><strong>同源</strong>指的是两个 URL 的协议、域名、端口一致，反之，则是<strong>跨域</strong>。</p><p>出现跨域的根本原因：<strong>浏览器的同源策略</strong>不允许非同源的 URL 之间进行资源的交互</p><h3 id="2、跨域的经典报错"><a href="#2、跨域的经典报错" class="headerlink" title="2、跨域的经典报错"></a>2、跨域的经典报错</h3><p>xxx has been blocked by CORS policy</p><h3 id="3、浏览器对跨域请求的拦截"><a href="#3、浏览器对跨域请求的拦截" class="headerlink" title="3、浏览器对跨域请求的拦截"></a>3、浏览器对跨域请求的拦截</h3><p>浏览器允许发起跨域请求，但是，<strong>跨域请求回来的数据，会被浏览器拦截</strong>，无法被页面获取到！</p><h3 id="4、HTML-中的跨域标签"><a href="#4、HTML-中的跨域标签" class="headerlink" title="4、HTML 中的跨域标签"></a>4、HTML 中的跨域标签</h3><p>img, script, link, video, iframe… 这些标签可以跨域请求资源</p><h3 id="5、实现跨域的常见几种方法"><a href="#5、实现跨域的常见几种方法" class="headerlink" title="5、实现跨域的常见几种方法"></a>5、实现跨域的常见几种方法</h3><ol><li><p>JSONP 方案: 利用跨域标签的特性发送 GET 请求获取数据 (缺点: 只能支持 GET 请求)</p></li><li><p>CORS 方案: 服务端处理跨域的一种技术手段, 开发中最为常用</p></li><li><p>代理服务器方案: 前端在本地开发的常用方案, 后面会学习专门的插件</p></li><li><p>手动关闭浏览器的同源策略: 不推荐使用, 安全性很差</p></li></ol><h3 id="6、JSONP的实现原理"><a href="#6、JSONP的实现原理" class="headerlink" title="6、JSONP的实现原理"></a>6、JSONP的实现原理</h3><ol><li><p>服务端提供一个函数进行调用, 并传入数据</p></li><li><p>客户端预先准备一个同名函数的声明</p></li><li><p>创建一个 script 标签, 利用 src 属性跨域去获取服务端上的函数调用</p></li></ol><p>注意：</p><ul><li><code>JSONP</code> 只支持 <code>GET</code> 数据请求，不支持 POST 请求。</li><li><strong><code>JSONP</code> 和 Ajax 之间没有任何关系</strong>，不能把 <code>JSONP</code> 请求数据的方式叫做 Ajax，因为 <code>JSONP</code> 没有用到<code>XMLHttpRequest</code> 这个对象</li></ul><h3 id="7、jQuery中的JSONP请求"><a href="#7、jQuery中的JSONP请求" class="headerlink" title="7、jQuery中的JSONP请求"></a>7、<code>jQuery</code>中的<code>JSONP</code>请求</h3><p> 默认情况下, 使用 jquery 发送 jsonp 请求, 会自动携带一个 ?callback=jQuery** 的随机数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">$.ajax(&#123;<br>          url: <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/jsonp&#x27;</span>,<br>          data: &#123;<br>              name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>              age: <span class="hljs-number">10</span><br>          &#125;,<br>          dataType: <span class="hljs-string">&#x27;JSONP&#x27;</span>,<br>          <span class="hljs-comment">// 更改回调函数的参数（一般很少操作，服务器会识别不了）</span><br>          <span class="hljs-comment">// jsonp: &#x27;cdk&#x27;,</span><br>          <span class="hljs-comment">// 更改回调函数的名字</span><br>          <span class="hljs-comment">// jsonpCallback: &#x27;foo&#x27;,</span><br>          success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>              <span class="hljs-built_in">console</span>.log(res);<br>          &#125;<br>      &#125;)<br></code></pre></td></tr></table></figure><h2 id="三、防抖-amp-节流"><a href="#三、防抖-amp-节流" class="headerlink" title="三、防抖&amp;节流"></a>三、防抖&amp;节流</h2><h3 id="1、防抖策略-debounce-解释"><a href="#1、防抖策略-debounce-解释" class="headerlink" title="1、防抖策略(debounce)解释"></a>1、防抖策略(debounce)解释</h3><p>当一个事件触发时, 不立即执行回调, 延迟一段时间后再执行; 在这段时间内事件再次触发,那么就重新开始计时</p><h3 id="2、防抖策略的好处"><a href="#2、防抖策略的好处" class="headerlink" title="2、防抖策略的好处"></a>2、防抖策略的好处</h3><p>当我们频繁, 连续触发某个事件时, 只会执行最后一次, 节省了请求资源</p><h3 id="3、防抖的应用场景"><a href="#3、防抖的应用场景" class="headerlink" title="3、防抖的应用场景"></a>3、防抖的应用场景</h3><p> 输入框连续输入字符, 浏览器窗口大小不断调整 </p><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 先定义一个定时器编号</span><br>        <span class="hljs-keyword">var</span> timeID = <span class="hljs-literal">null</span>;<br>        $(<span class="hljs-string">&#x27;button&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// 清除原来的定时器</span><br>            <span class="hljs-built_in">clearTimeout</span>(timeID);<br>            <span class="hljs-comment">// 再设置一个新的定时器</span><br>            timeID = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-number">132</span>);<br>            &#125;, <span class="hljs-number">500</span>)<br>        &#125;)<br></code></pre></td></tr></table></figure><h3 id="4、缓存搜索的建议列表"><a href="#4、缓存搜索的建议列表" class="headerlink" title="4、缓存搜索的建议列表"></a>4、缓存搜索的建议列表</h3><ol><li><p>定义全局缓存对象</p></li><li><p>定义全局缓存对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 缓存对象</span><br><span class="hljs-keyword">var</span> cacheObj = &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>将搜索结果保存到缓存对象中</p><ul><li>键就是用户输入的关键字，值就是服务器返回的value</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 渲染建议列表</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderSuggestList</span>(<span class="hljs-params">res</span>) </span>&#123;<br>     <span class="hljs-comment">// ...省略其他代码</span><br>     <span class="hljs-comment">// 将搜索的结果，添加到缓存对象中</span><br>     <span class="hljs-keyword">var</span> k = $(<span class="hljs-string">&#x27;#ipt&#x27;</span>).val().trim()<br>     cacheObj[k] = res<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>优先从缓存中获取搜索建议</p><ul><li>在发起请求之前，先判断缓存中是否有数据</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听文本框的 keyup 事件</span><br>$(<span class="hljs-string">&#x27;#ipt&#x27;</span>).on(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-comment">// ...省略其他代码</span><br>     <span class="hljs-comment">// 优先从缓存中获取搜索建议</span><br>     <span class="hljs-keyword">if</span> (cacheObj[keywords]) &#123;<br>     <span class="hljs-keyword">return</span> renderSuggestList(cacheObj[keywords])<br>     &#125;<br>     <span class="hljs-comment">// 获取搜索建议列表</span><br>     debounceSearch(keywords)<br> &#125;)<br></code></pre></td></tr></table></figure><h3 id="5、节流"><a href="#5、节流" class="headerlink" title="5、节流"></a>5、节流</h3></li><li><p>定义</p><p>顾名思义，可以减少一段时间内事件的触发频率。</p></li><li><p>节流的应用场景</p><p>① 鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次；</p><p>② 懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费 CPU 资源；</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个节流阀，默认为打开</span><br>        <span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span>;<br><br>        $(<span class="hljs-string">&quot;button&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// 判断当前阀门是否打开</span><br>            <span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span>;<br><br>            <span class="hljs-comment">// 开始执行动画前，先关闭阀门</span><br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>);<br><br>                <span class="hljs-comment">// 动画结束后，打开阀门</span><br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;, <span class="hljs-number">500</span>)<br>        &#125;)<br></code></pre></td></tr></table></figure><p>案例：小天使鼠标跟随效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">//定义一个节流阀,默认打开</span><br>           <span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span>;<br>           <span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span>;<br>           $(<span class="hljs-built_in">document</span>).mousemove(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>               <span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span>;<br>               <span class="hljs-comment">//动画开始前关闭</span><br>               flag = <span class="hljs-literal">false</span>;<br>               <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                   <span class="hljs-comment">// 打印鼠标移动次数</span><br>                   <span class="hljs-built_in">console</span>.log(num++);<br><br>                   $(<span class="hljs-string">&#x27;img&#x27;</span>).css(&#123;<br>                       left: e.pageX,<br>                       top: e.pageY<br>                   &#125;);<br> <span class="hljs-comment">//动画结束后打开</span><br>                   flag = <span class="hljs-literal">true</span>;<br>               &#125;, <span class="hljs-number">20</span>)<br>           &#125;)<br>       &#125;)<br></code></pre></td></tr></table></figure><h3 id="6、防抖和节流的区别"><a href="#6、防抖和节流的区别" class="headerlink" title="6、防抖和节流的区别"></a>6、防抖和节流的区别</h3><ul><li><p>防抖和节流的共同点:</p><ol><li><p>都能有效地降低事件触发的频率</p></li><li><p>都能节省资源, 优化性能和用户体验</p></li></ol></li><li><p>防抖和节流的不同点:</p><ol><li><p>防抖在频繁触发事件的情况下, 只有最后一次生效; 节流则是在单位时间内生效一次</p></li><li><p>防抖实现的核心是 “销毁定时器”; 节流实现的核心是 “更新节流阀”</p></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>Ajax学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax第三天</title>
    <link href="/2021/02/04/Ajax%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
    <url>/2021/02/04/Ajax%E7%AC%AC%E4%B8%89%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax第三天"><a href="#Ajax第三天" class="headerlink" title="Ajax第三天"></a>Ajax第三天</h1><h2 id="一、XMLHttpRequest的基本使用"><a href="#一、XMLHttpRequest的基本使用" class="headerlink" title="一、XMLHttpRequest的基本使用"></a>一、<code>XMLHttpRequest</code>的基本使用</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p> 浏览器为我们提供的一个内置对象(构造函数), 通过它我们可以向服务器发送请求, 并接受响应</p><p>  $.ajax() 请求方法底层就是 jQuery 封装这个对象的一系列方法来实现的</p><h3 id="2、使用xhr发起GET请求"><a href="#2、使用xhr发起GET请求" class="headerlink" title="2、使用xhr发起GET请求"></a>2、使用<code>xhr</code>发起GET请求</h3><ul><li><p>步骤：</p><ul><li><p>创建 <code>xhr</code> 对象</p></li><li><p>调用 <code>xhr.open()</code> 函数</p></li><li><p>调用 <code>xhr.send()</code> 函数</p></li><li><p>监听 <code>xhr.onreadystatechange</code> 事件</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 构建 xhr 实例对象</span><br>    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    <span class="hljs-comment">// 2. 初始化请求 open(请求方式，url地址)</span><br>    xhr.open(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>);<br>    <span class="hljs-comment">// 3. 发送请求  send()</span><br>    xhr.send();<br>    <span class="hljs-comment">// 4. 监听请求状态, 获取响应的数据</span><br>    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br> <span class="hljs-comment">// 判断请求是否完成，HTTP请求状态码是否成功</span><br>        <span class="hljs-keyword">if</span> (xhr.readyState == <span class="hljs-number">4</span> &amp;&amp; xhr.status == <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-comment">// 获取响应数据  </span><br>     <span class="hljs-built_in">console</span>.log(xhr.responseText);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">// onload表示请求已经完成，和上面if判断作用相同</span><br>    xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// 获取响应数据</span><br>        <span class="hljs-built_in">console</span>.log(xhr.responseText);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>if判断代码中xhr.status不是返回数据中的status</p><h3 id="3、了解xhr对象的readyState属性"><a href="#3、了解xhr对象的readyState属性" class="headerlink" title="3、了解xhr对象的readyState属性"></a>3、了解<code>xhr</code>对象的<code>readyState</code>属性</h3><ul><li>xhr 请求的所有状态码<ul><li>0 (未初始化) ==&gt; 请求还未初始化</li><li>1 (正在加载) ==&gt; 已建立服务器链接</li><li> 2 (加载成功) ==&gt; 请求已接受</li><li>3 (交互)   ==&gt; 正在处理请求</li><li>4 (完成)   ==&gt; 请求已完成, 响应数据已传输</li></ul></li></ul><h3 id="4、查询参数"><a href="#4、查询参数" class="headerlink" title="4、查询参数"></a>4、查询参数</h3><ul><li><p>定义：在 url 末尾添加的以 ? 开头的参数，叫做查询参数</p><p>比如： <a href="http://www.youxi.cn/?hero=tank&amp;money=99&amp;skin=pink">http://www.youxi.cn?hero=tank&amp;money=99&amp;skin=pink</a></p></li><li><p>参数特征</p><p>格式符合键值对的格式，多个键值对之间使用 &amp; 符号进行连接</p></li><li><p>作用</p></li></ul><ol><li><p>多个页面之间传递数据(从首页跳转到首页，显示登录名（location.search）);</p></li><li><p>给服务器发送 get 请求的数据</p></li></ol><h3 id="5、get请求带参数的写法"><a href="#5、get请求带参数的写法" class="headerlink" title="5、get请求带参数的写法"></a>5、get请求带参数的写法</h3><p>把 参数 按键值对字符串的形式拼接到 url 后面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>        xhr.open(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/get?name=ZhangSan&amp;&amp;age=12&amp;&amp;sex=man&#x27;</span>);<br>        xhr.send();<br>        xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (xhr.readyState == <span class="hljs-number">4</span> &amp;&amp; xhr.status == <span class="hljs-number">200</span>) &#123;<br>                <span class="hljs-built_in">console</span>.log(xhr.responseText);<br>            &#125;;<br>        &#125;;<br></code></pre></td></tr></table></figure><h3 id="6、URL编码"><a href="#6、URL编码" class="headerlink" title="6、URL编码"></a>6、URL编码</h3><p>浏览器中的 URL 中只允许出现字母, 符号和数字, 不允许出现汉字, 如果出现需要对其进行编码</p><ol><li>编码的规则：</li></ol><p>使用字母，数字和特殊符号对其他字符(如汉字)进行编码</p><ol start="2"><li><p>浏览器内置的 URL 编码和解码方法</p><p>encodeURI(参数) 对参数进行 URI 编码</p><p>decodeURI(参数) 对参数进行 URI 解码</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;2月6号放假&#x27;</span><br>      <span class="hljs-keyword">var</span> str2 = <span class="hljs-built_in">encodeURI</span>(str);<br>      <span class="hljs-built_in">console</span>.log(str2);<br>      <span class="hljs-keyword">var</span> str3 = <span class="hljs-built_in">decodeURI</span>(<span class="hljs-string">&#x27;%E6%94%BE%E5%81%87&#x27;</span>);<br>      <span class="hljs-built_in">console</span>.log(str3);<span class="hljs-comment">//反编译为 放假</span><br></code></pre></td></tr></table></figure><h3 id="7、post请求原生写法"><a href="#7、post请求原生写法" class="headerlink" title="7、post请求原生写法"></a>7、post请求原生写法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>      xhr.open(<span class="hljs-string">&#x27;post&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/addbook&#x27;</span>);<br>      <span class="hljs-comment">// 设置post请求参数的编码方式</span><br>      xhr.setRequestHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>);<br>      <span class="hljs-comment">// 设置post请求时，要传递键值对字符串</span><br>      xhr.send(<span class="hljs-string">&#x27;bookname=熟虾&amp;author=之颂&amp;publisher=125&#x27;</span>);<br>      xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-keyword">if</span> (xhr.readyState == <span class="hljs-number">4</span> &amp;&amp; xhr.status == <span class="hljs-number">200</span>) &#123;                <span class="hljs-built_in">console</span>.log(xhr.responseText);<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure><h2 id="二、数据交换格式"><a href="#二、数据交换格式" class="headerlink" title="二、数据交换格式"></a>二、数据交换格式</h2><h3 id="1、数据交换格式"><a href="#1、数据交换格式" class="headerlink" title="1、数据交换格式"></a>1、数据交换格式</h3><pre><code> 客户端和服务端之间进行数据传输时, 需要使用公共的数据格式.。</code></pre><p><strong>JSON 是前后端开发中最常用的一种轻量级数据交换格式</strong>,除此之外还有 XML 这种带有语义化的数据格式。</p><ul><li><code>XML</code> 的英文全称是 <code>EXtensible Markup Language</code>，即<strong>可扩展标记语言</strong>。</li><li>XML和HTML的区别：<ul><li><code>HTML</code> 被设计用来描述网页上的<strong>内容</strong>，是网页内容的载体</li><li><code>XML</code> 被设计用来<strong>传输和存储数据</strong>，是数据的载体</li><li><strong>客户端向服务器</strong>发送数据利用的是XML，<strong>服务器向客户端</strong>发送数据利用的是HTML</li></ul></li><li>XML的缺点<ul><li><code>XML</code> 格式臃肿，和数据无关的代码多，体积大，传输效率低</li><li>在 <code>Javascript</code> 中解析 <code>XML</code> 比较麻烦</li></ul></li></ul><h3 id="2、JSON（JavaScript-Object-Notation-）"><a href="#2、JSON（JavaScript-Object-Notation-）" class="headerlink" title="2、JSON（JavaScript Object Notation ）"></a>2、JSON（JavaScript Object Notation ）</h3><p> JSON 可以理解为 js 中对象的字符串表示法, 本质上还是一个字符串。</p><ol><li><p><strong>概念：</strong><code>JSON</code> 的英文全称是 <code>JavaScript Object Notation</code>，即“<strong>JavaScript 对象表示法</strong>”。</p></li><li><p><strong>作用：</strong><code>JSON</code> 是一种轻量级的文本数据交换格式，在作用上类似于 <code>XML</code>，<strong>专门用于存储和传输数据</strong>，但</p><p>是 <code>JSON</code> 比 <code>XML</code> <strong>更小、更快、更易解析</strong>。</p></li></ol><h3 id="3、JSON-数据格式的注意"><a href="#3、JSON-数据格式的注意" class="headerlink" title="3、JSON 数据格式的注意"></a>3、JSON 数据格式的注意</h3><ol><li><p>普通对象最外层使用 {  } 包裹, 数组的最外层使用 [  ] 包裹</p></li><li><p>属性名和字符串必须是双引号括起来的字符串, 最后一个属性后不能有逗号（必须严格遵守）</p></li><li><p>属性值或数组元素可以是 number, string, boolean, array, null, object 6种</p><p>​        但不能是 undefined 和 function</p></li><li><p>不能在 json 中填写注释</p></li></ol><p><strong><code>JSON</code> 的作用：</strong>在计算机与网络之间存储和传输数据。</p><p><strong><code>JSON</code> 的本质：</strong>用字符串来表示 <code>Javascript</code> 对象数据或数组数据</p><h3 id="4、JSON和JS对象的关系"><a href="#4、JSON和JS对象的关系" class="headerlink" title="4、JSON和JS对象的关系"></a>4、<code>JSON</code>和<code>JS</code>对象的关系</h3><p><code>JSON</code> 是 <code>JS</code> 对象的字符串表示法，它使用文本表示一个 <code>JS</code> 对象的信息，本质是一个字符串。</p><h3 id="5、JSON和JS对象的互转"><a href="#5、JSON和JS对象的互转" class="headerlink" title="5、JSON和JS对象的互转"></a>5、<code>JSON</code>和<code>JS</code>对象的互转</h3><ol><li>要实现从 <code>JSON</code> 字符串转换为 <code>JS</code> 对象，使用 <code>JSON.parse()</code> 方法：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj=<span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;&#123;&quot;a&quot;:&quot;Hello&quot;,&quot;b&quot;:&quot;World&quot;&#125;&#x27;</span>);<br><span class="hljs-comment">//结果是：&#123;a:&#x27;Hello&#x27;,b:&#x27;World&#x27;&#125;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>要实现从 <code>JS</code> 对象转换为 <code>JSON</code> 字符串，使用 <code>JSON.stringify()</code> 方法：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> json=<span class="hljs-built_in">JSON</span>.stringify(&#123;<span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;Hello&#x27;</span>,<span class="hljs-attr">b</span>:<span class="hljs-string">&#x27;World&#x27;</span>&#125;);<br><span class="hljs-comment">//结果是：&#x27;&#123;&quot;a&quot;:&quot;Hello&quot;,&quot;b&quot;:&quot;World&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>总结：<code> JSON.stringify()</code>   <code>JSON.parse()</code></p><ol><li><p><code>todolist</code> 本地存储， 只能存储字符串格式的数据， <code>JSON.stringify()</code></p></li><li><p>JS高级 深拷贝： JSON.parse(JSON.stringify(obj)) //生成的是一个新对象</p></li><li><p>把服务器返回的json字符串解析成js对象格式 JSON.parse()</p></li></ol></li></ol><h3 id="6、序列化和反序列化"><a href="#6、序列化和反序列化" class="headerlink" title="6、序列化和反序列化"></a>6、序列化和反序列化</h3><p>把<strong>数据对象</strong> <strong>转换为</strong> <strong>字符串</strong>的过程，叫做<strong>序列化</strong>，例如：调用 <code>JSON.stringify()</code> 函数的操作，叫做 <code>JSON</code> 序列化。</p><p>把<strong>字符串</strong> <strong>转换为</strong> <strong>数据对象</strong>的过程，叫做<strong>反序列化</strong>，例如：调用 <code>JSON.parse()</code> 函数的操作，叫做 <code>JSON</code> 反序列化。</p><h2 id="三、XMLHttpRequest-Level2的新特性"><a href="#三、XMLHttpRequest-Level2的新特性" class="headerlink" title="三、XMLHttpRequest Level2的新特性"></a>三、<code>XMLHttpRequest Level2</code>的新特性</h2><h3 id="1、老版本-XMLHttpRequest-问题"><a href="#1、老版本-XMLHttpRequest-问题" class="headerlink" title="1、老版本 XMLHttpRequest 问题"></a>1、老版本 <code>XMLHttpRequest</code> 问题</h3><ol><li><p>只支持文本数据的传送，无法用来读取和上传二进制文件</p></li><li><p>传送和接收数据时，没有进度信息，只能提示有没有完成</p></li></ol><h3 id="2、新版本-XMLHttpRequest-特性"><a href="#2、新版本-XMLHttpRequest-特性" class="headerlink" title="2、新版本 XMLHttpRequest 特性"></a>2、新版本 XMLHttpRequest 特性</h3><ol><li><p>可以设置 HTTP 请求的超时时限</p></li><li><p>可以使用 FormData 对象管理表单数据</p></li><li><p>可以上传文件</p></li><li><p>可以获取数据请求的进度信息</p></li></ol><h3 id="3、为-ajax-请求设置超时限制"><a href="#3、为-ajax-请求设置超时限制" class="headerlink" title="3、为 ajax 请求设置超时限制"></a>3、为 ajax 请求设置超时限制</h3><ul><li><p>设置超时时间（默认为毫秒）</p><p>xhr.timeout = 超时时间</p></li><li><p>xhr 实例的超时事件</p><p>   xhr.ontimeout = fn</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>       xhr.timeout = <span class="hljs-number">10</span>;<br>    xhr.addEventListener(<span class="hljs-string">&#x27;timeout&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> alert(<span class="hljs-string">&#x27;请求超时&#x27;</span>)&#125;);<br>           xhr.open(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/get&#x27;</span>);<br>           xhr.send();<br>           xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">if</span> (xhr.readyState == <span class="hljs-number">4</span> &amp;&amp; xhr.status == <span class="hljs-number">200</span>) &#123;<br>         <span class="hljs-built_in">console</span>.log(xhr.responseText);<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><h2 id="四、FormData对象管理表单数据"><a href="#四、FormData对象管理表单数据" class="headerlink" title="四、FormData对象管理表单数据"></a>四、<code>FormData</code>对象管理表单数据</h2><h3 id="1、什么是FormData？"><a href="#1、什么是FormData？" class="headerlink" title="1、什么是FormData？"></a>1、什么是FormData？</h3><p>浏览器提供的一个内置对象(构造函数), 可以轻松管理表单数据的键值对 (key/value)</p><h3 id="2、FormData-相关方法"><a href="#2、FormData-相关方法" class="headerlink" title="2、FormData 相关方法"></a>2、FormData 相关方法</h3><ol><li><p>添加一条数据 append()</p></li><li><p>查询一条数据 get()</p></li><li><p>设置一条数据 set()</p></li><li><p>遍历数据 forEach()</p></li></ol><h3 id="3、在-Ajax-中的使用"><a href="#3、在-Ajax-中的使用" class="headerlink" title="3、在 Ajax 中的使用"></a>3、在 Ajax 中的使用</h3><p>可以直接使用 send 方法发送 formData 格式的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 新建一个 FormData 对象</span><br>        <span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> FormData();<br><br>        <span class="hljs-comment">// 2. 添加一条数据: append()</span><br>        fd.append(<span class="hljs-string">&#x27;bookname&#x27;</span>, <span class="hljs-string">&#x27;儒林外史&#x27;</span>);<br>        fd.append(<span class="hljs-string">&#x27;author&#x27;</span>, <span class="hljs-string">&#x27;费瓦罗纳&#x27;</span>);<br>        fd.append(<span class="hljs-string">&#x27;publisher&#x27;</span>, <span class="hljs-string">&#x27;圣埃蒂安&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(fd.get(<span class="hljs-string">&#x27;author&#x27;</span>));<br><br>        <span class="hljs-comment">// 3. 设置一条数据: set()</span><br>        fd.set(<span class="hljs-string">&#x27;publisher&#x27;</span>, <span class="hljs-string">&#x27;埃尔法&#x27;</span>);<br>        fd.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(item);<br>        &#125;);<br>        <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>        xhr.open(<span class="hljs-string">&#x27;post&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/formdata&#x27;</span>);<br>        xhr.send(fd);<br><br>        xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (xhr.readyState == <span class="hljs-number">4</span> &amp;&amp; xhr.status == <span class="hljs-number">200</span>) &#123;<br>                <span class="hljs-built_in">console</span>.log(xhr.responseText);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="4、formData快速获取表单数据"><a href="#4、formData快速获取表单数据" class="headerlink" title="4、formData快速获取表单数据"></a>4、formData快速获取表单数据</h3><p>使用 new FormData(原生form元素) 可以一次性获取表单中所有的数据 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;form&#x27;</span>).submit(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>         e.preventDefault();<br>         <span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> FormData(<span class="hljs-built_in">this</span>);<br>         <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>         xhr.open(<span class="hljs-string">&#x27;post&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/formdata&#x27;</span>);<br>         xhr.send(fd);<br>         xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.parse(xhr.responseText));<br>         &#125;<br>     &#125;);<br></code></pre></td></tr></table></figure><h2 id="五、formData上传文件"><a href="#五、formData上传文件" class="headerlink" title="五、formData上传文件"></a>五、formData上传文件</h2><h3 id="1、案例：formData上传文件并显示文件上传进度-原生方法"><a href="#1、案例：formData上传文件并显示文件上传进度-原生方法" class="headerlink" title="1、案例：formData上传文件并显示文件上传进度(原生方法)"></a>1、案例：formData上传文件并显示文件上传进度(原生方法)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#upload-btn&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-comment">// (原生文本选择框.files)</span><br>           <span class="hljs-keyword">var</span> files = $(<span class="hljs-string">&#x27;#file&#x27;</span>)[<span class="hljs-number">0</span>].files;<br>           <span class="hljs-comment">// 判断文件列表长度</span><br>           <span class="hljs-keyword">if</span> (files.length &lt;= <span class="hljs-number">0</span>) &#123;<br>               <span class="hljs-keyword">return</span> alert(<span class="hljs-string">&#x27;请选择文件上传&#x27;</span>);<br>           &#125;;<br>           <span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> FormData();<br>           <span class="hljs-comment">// 向fd中添加一个数据</span><br>           fd.append(<span class="hljs-string">&#x27;avatar&#x27;</span>, files[<span class="hljs-number">0</span>]);<br><br>           <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><br>           <span class="hljs-comment">// 绑定上传进度事件</span><br>           xhr.upload.onprogress = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>               <span class="hljs-comment">// console.log(e.lengthComputable);</span><br>               <span class="hljs-comment">// 判断当前文件是否可计算</span><br>               <span class="hljs-keyword">if</span> (e.lengthComputable) &#123;<br>                   <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(e.loaded / e.total * <span class="hljs-number">100</span>));<br>                   <span class="hljs-comment">// 获取文件上传进度e.total表示总数据量， e.loaded表示已经上传的数据量</span><br>                   <span class="hljs-keyword">var</span> percentage = <span class="hljs-built_in">parseInt</span>(e.loaded / e.total * <span class="hljs-number">100</span>) + <span class="hljs-string">&#x27;%&#x27;</span>;<br>                   <span class="hljs-comment">// 给进度条设置width样式属性和内容</span><br>                   $(<span class="hljs-string">&#x27;#bar&#x27;</span>).css(<span class="hljs-string">&#x27;width&#x27;</span>, percentage).text(percentage);<br>               &#125;;<br>           &#125;;<br>           <span class="hljs-comment">// 为xhr绑定文件获取成功事件</span><br>           xhr.upload.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>               $(<span class="hljs-string">&#x27;#bar&#x27;</span>).removeClass().addClass(<span class="hljs-string">&#x27;progress-bar progress-bar-success&#x27;</span>)<br>           &#125;<br><br>           xhr.open(<span class="hljs-string">&#x27;post&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/upload/avatar&#x27;</span>);<br>           xhr.send(fd);<br>           xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>               <span class="hljs-keyword">var</span> res = <span class="hljs-built_in">JSON</span>.parse(xhr.responseText)<br>               <span class="hljs-built_in">console</span>.log(res);<br>               <span class="hljs-comment">// 将地址给img标签</span><br>               $(<span class="hljs-string">&#x27;img&#x27;</span>).prop(<span class="hljs-string">&#x27;src&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006&#x27;</span> + res.url);<br>           &#125;<br>       &#125;)<br></code></pre></td></tr></table></figure><h3 id="2、jq版本文件上传"><a href="#2、jq版本文件上传" class="headerlink" title="2、jq版本文件上传"></a>2、jq版本文件上传</h3><ul><li><h3 id="ajaxStart-callback"><a href="#ajaxStart-callback" class="headerlink" title="ajaxStart(callback)"></a><code>ajaxStart(callback)</code></h3><p><code>Ajax</code> 请求<strong>开始</strong>时，执行 <code>ajaxStart</code> 函数。</p><ul><li><strong>注意：</strong> <code>$(document).ajaxStart()</code> 函数<strong>会监听当前文档内所有的 Ajax 请求</strong>。</li></ul></li><li><h3 id="ajaxStop-callback"><a href="#ajaxStop-callback" class="headerlink" title="ajaxStop(callback)"></a><code>ajaxStop(callback)</code></h3><p><code>Ajax</code> 请求<strong>结束</strong>时，执行 <code>ajaxStop</code> 函数。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-built_in">document</span>).ajaxStart(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>               $(<span class="hljs-string">&#x27;#loading&#x27;</span>).show()<br>           &#125;);<br>           $(<span class="hljs-string">&#x27;#upload-btn&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>               <span class="hljs-comment">// (原生文本选择框.files)</span><br>               <span class="hljs-keyword">var</span> files = $(<span class="hljs-string">&#x27;#file&#x27;</span>)[<span class="hljs-number">0</span>].files;<br>               <span class="hljs-comment">// 判断文件列表长度</span><br>               <span class="hljs-keyword">if</span> (files.length &lt;= <span class="hljs-number">0</span>) &#123;<br>                   <span class="hljs-keyword">return</span> alert(<span class="hljs-string">&#x27;请选择文件上传&#x27;</span>);<br>               &#125;;<br>               <span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> FormData();<br>               <span class="hljs-comment">// 向fd中添加一个数据</span><br>               fd.append(<span class="hljs-string">&#x27;avatar&#x27;</span>, files[<span class="hljs-number">0</span>]);<br><br>               $.ajax(&#123;<br>                   url: <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/upload/avatar&#x27;</span>,<br>                   method: <span class="hljs-string">&#x27;post&#x27;</span>,<br>                   data: fd,<br>                   <span class="hljs-comment">// 使用formdata 默认参数编码 multipart/form-data</span><br>                   contentType: <span class="hljs-literal">false</span>,<br>                   <span class="hljs-comment">// 不需要对请求体中内容进行额外处理</span><br>                   processData: <span class="hljs-literal">false</span>,<br>                   <span class="hljs-comment">// 发送ajax请求前调用</span><br>                   beforeSend: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                       <span class="hljs-comment">// console.log(123);</span><br>                       $(<span class="hljs-string">&#x27;#loading&#x27;</span>).show()<br>                   &#125;,<br>                   success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>                       <span class="hljs-built_in">console</span>.log(res);<br>                       $(<span class="hljs-string">&#x27;#loading&#x27;</span>).prop(<span class="hljs-string">&#x27;src&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006&#x27;</span> + res.url);<br>                   &#125;<br>               &#125;)<br>           &#125;)<br></code></pre></td></tr></table></figure><h2 id="六、什么是axios"><a href="#六、什么是axios" class="headerlink" title="六、什么是axios"></a>六、什么是<code>axios</code></h2><h3 id="1、定义："><a href="#1、定义：" class="headerlink" title="1、定义："></a>1、定义：</h3><p><code>Axios</code> 是专注于<strong>网络数据请求</strong>的库。</p><p>相比于原生的 <code>XMLHttpRequest</code> 对象，<code>axios</code> <strong>简单易用</strong>。</p><p>相比于 <code>jQuery</code>，<code>axios</code> 更加<strong>轻量化</strong>，只专注于网络数据请求。</p><h3 id="2、axios发起GET请求"><a href="#2、axios发起GET请求" class="headerlink" title="2、axios发起GET请求"></a>2、<code>axios</code>发起GET请求</h3><p><code>axios.get()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.get(<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/get&#x27;</span>, &#123;<br>            params: &#123;<br>                id: <span class="hljs-number">10</span>,<br>                age: <span class="hljs-number">20</span><br>            &#125;<br>        &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(res.data);<br>        &#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(err);<br>        &#125;)<br></code></pre></td></tr></table></figure><h3 id="3、axios发起POST请求"><a href="#3、axios发起POST请求" class="headerlink" title="3、axios发起POST请求"></a>3、<code>axios</code>发起<code>POST</code>请求</h3><p><code>axios.post()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.post(<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/post&#x27;</span>, &#123;<br>            name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>            age: <span class="hljs-number">10</span>,<br>            height: <span class="hljs-number">170</span><br>        &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(res);<br>        &#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(err);<br>        &#125;)<br></code></pre></td></tr></table></figure><h3 id="4、直接使用axios发起请求"><a href="#4、直接使用axios发起请求" class="headerlink" title="4、直接使用axios发起请求"></a>4、直接使用<code>axios</code>发起请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//发起get请求</span><br>axios(&#123;<br>            url: <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>,<br>            method: <span class="hljs-string">&#x27;get&#x27;</span>,<br>            params: &#123;<br>                id: <span class="hljs-number">1</span>,<br>                bookname: <span class="hljs-string">&#x27;西游记&#x27;</span><br>            &#125;<br>        &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(res.data);<br>        &#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(err);<br>        &#125;)<br><span class="hljs-comment">//发起post请求</span><br>        axios(&#123;<br>            url: <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/addbook&#x27;</span>,<br>            method: <span class="hljs-string">&#x27;post&#x27;</span>,<br>            data: &#123;<br>                bookname: <span class="hljs-string">&#x27;儒林外史&#x27;</span>,<br>                author: <span class="hljs-string">&#x27;年份酒偶发&#x27;</span>,<br>                publisher: <span class="hljs-string">&#x27;阿萨德刚&#x27;</span><br>            &#125;<br>        &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(res.data);<br>        &#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(err);<br>        &#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Ajax学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高级第五天</title>
    <link href="/2021/02/04/JS%E7%AC%AC%E4%BA%94%E5%A4%A9/"/>
    <url>/2021/02/04/JS%E7%AC%AC%E4%BA%94%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="JS第五天"><a href="#JS第五天" class="headerlink" title="JS第五天"></a>JS第五天</h1><h2 id="一、ES6相关概念"><a href="#一、ES6相关概念" class="headerlink" title="一、ES6相关概念"></a>一、ES6相关概念</h2><h3 id="1、什么是ES6"><a href="#1、什么是ES6" class="headerlink" title="1、什么是ES6"></a>1、什么是ES6</h3><p>ES 的全称是 ECMAScript ,从2015年6月开始每年都会更新一下，统称为ES6</p><h3 id="2、使用ES6的目的"><a href="#2、使用ES6的目的" class="headerlink" title="2、使用ES6的目的"></a>2、使用ES6的目的</h3><ul><li>变量提升特性增加了程序运行时的不可预测性</li><li>语法过于松散，实现相同的功能，不同的人可能会写出不同的代码</li></ul><h2 id="二、ES6新增语法"><a href="#二、ES6新增语法" class="headerlink" title="二、ES6新增语法"></a>二、ES6新增语法</h2><h3 id="1、let-（★★★）"><a href="#1、let-（★★★）" class="headerlink" title="1、let （★★★）"></a>1、let （★★★）</h3><h4 id="1-1-作用："><a href="#1-1-作用：" class="headerlink" title="1.1 作用："></a>1.1 作用：</h4><p>用来声明一个有块级作用域的变量，使用方法和 var 一样</p><h4 id="1-2-let-定义变量的特点："><a href="#1-2-let-定义变量的特点：" class="headerlink" title="1.2 let 定义变量的特点："></a>1.2 let 定义变量的特点：</h4><ol><li><p>只在声明时的块或子块中可用</p></li><li><p>不存在变量提升，只能先声明再使用</p></li><li><p>存在“暂存死区”</p></li><li><p>同一作用域下不能重复声明同一变量</p></li><li><p>声明的变量不会挂载在 window 对象上 </p></li></ol><h4 id="1-3-暂时性死区的本质"><a href="#1-3-暂时性死区的本质" class="headerlink" title="1.3 暂时性死区的本质"></a>1.3 暂时性死区的本质</h4><p>  只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> bar = <span class="hljs-number">20</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>          <span class="hljs-comment">//bar存在当前的块级作用域中，但无法提前访问</span><br>          <span class="hljs-built_in">console</span>.log(bar);<span class="hljs-comment">//会报错</span><br>          <span class="hljs-keyword">let</span> bar = <span class="hljs-number">10</span>;<br>      &#125;<br></code></pre></td></tr></table></figure><h4 id="1-4经典面试题："><a href="#1-4经典面试题：" class="headerlink" title="1.4经典面试题："></a>1.4经典面试题：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [];<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        arr[i] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>        &#125;<br>    &#125;<br>      arr[<span class="hljs-number">0</span>]();<span class="hljs-comment">//0</span><br>      arr[<span class="hljs-number">1</span>]();<span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><h3 id="2、const关键字"><a href="#2、const关键字" class="headerlink" title="2、const关键字"></a>2、const关键字</h3><h4 id="2-1const-作用"><a href="#2-1const-作用" class="headerlink" title="2.1const 作用"></a>2.1const 作用</h4><p>用来声明一个有块级作用域的常量(内存地址不能变化的量)</p><h4 id="2-2const-定义常量的特点"><a href="#2-2const-定义常量的特点" class="headerlink" title="2.2const 定义常量的特点"></a>2.2const 定义常量的特点</h4><ol><li><p>声明常量时必须要初始化值</p></li><li><p>同样具有块级作用域和“暂存死区”</p></li><li><p>赋值为简单数据类型时，不能直接修改值</p></li><li><p>赋值为复杂数据类型时，可以修改对象内部的属性和方法</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = &#123;<br>         a: <span class="hljs-number">1</span>,<br>         b: <span class="hljs-number">2</span><br>     &#125;;<br>     data.a = <span class="hljs-number">10</span> <span class="hljs-comment">//这里可以通过，原因是data的内存地址值没有发生改变</span><br>         <span class="hljs-comment">// data = []; //报错，原因是data的地址值发生了改变</span><br></code></pre></td></tr></table></figure><h4 id="2-3、let、const、var-的区别"><a href="#2-3、let、const、var-的区别" class="headerlink" title="2.3、let、const、var 的区别"></a>2.3、let、const、var 的区别</h4><p><img src="E:\黑马培训\前端基础\案例练习\就业班\笔记\JS高级\JS高级第五天\images\var&let&const区别.png" alt="var&amp;let&amp;const区别"></p><h3 id="3、解构赋值"><a href="#3、解构赋值" class="headerlink" title="3、解构赋值"></a>3、解构赋值</h3><h4 id="3-1解构赋值（强大）"><a href="#3-1解构赋值（强大）" class="headerlink" title="3.1解构赋值（强大）"></a>3.1解构赋值（强大）</h4><p>可以从数组或对象中，把值取出来，再赋值给对应的变量</p><h4 id="3-2对数组进行解构"><a href="#3-2对数组进行解构" class="headerlink" title="3.2对数组进行解构"></a>3.2对数组进行解构</h4><p> let [a, b, …] = 数组</p><p>   使用变量名和对应位置的数组元素一一匹配，匹配成功就把元素赋值给变量</p><ul><li><p><strong>使用注意</strong></p><p> (1) 没有解构成功的变量，值为 undefined</p><p> (2) 变量的位置和数组中值的位置一一对应</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 没有解构成功的变量，值为 undefined</span><br>      <span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">4</span>];<br>      <span class="hljs-keyword">let</span> [aa, bb] = arr2;<br>      <span class="hljs-built_in">console</span>.log(aa, bb); <span class="hljs-comment">//4  undefined</span><br>      <span class="hljs-comment">// 2. 不需要解构的元素可以使用 逗号 隔开</span><br>      <span class="hljs-keyword">let</span> [, a1, b1] = arr;<br>      <span class="hljs-built_in">console</span>.log(a1, b1);<br>      <span class="hljs-comment">// 3. 交换两个变量</span><br>      <span class="hljs-keyword">let</span> num1 = <span class="hljs-number">10</span>;<br>      <span class="hljs-keyword">let</span> num2 = <span class="hljs-number">20</span>;<br>      [num1, num2] = [num2, num1];<br>      <span class="hljs-built_in">console</span>.log(num1, num2); <span class="hljs-comment">//20  10</span><br></code></pre></td></tr></table></figure><h4 id="3-3对对象进行解构"><a href="#3-3对对象进行解构" class="headerlink" title="3.3对对象进行解构"></a>3.3对对象进行解构</h4><p>   let {prop1, prop2, …} = 对象</p><p>   使用变量名和对象中的属性名进行一一匹配，匹配成功就把对象的属性值赋值给变量</p><ul><li><p><strong>使用注意</strong></p><p>   (1) 没有解构成功的变量，值为 undefined</p><p>   (2) 变量的名称和属性名一一对应</p><p>   (3) 变量名的顺序和数量没有要求</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>                name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>                age: <span class="hljs-number">18</span>,<br>                height: <span class="hljs-string">&#x27;175cm&#x27;</span>,<br>                weight: <span class="hljs-string">&#x27;65kg&#x27;</span><br>            &#125;<br> <span class="hljs-comment">// 没有解构成功的变量，值为 undefined</span><br>        <span class="hljs-keyword">let</span> &#123;<br>            sex<br>        &#125; = obj;<br>        <span class="hljs-built_in">console</span>.log(sex);<span class="hljs-comment">//undefined</span><br>      <span class="hljs-comment">// 变量名的顺序和数量没有要求</span><br>      <span class="hljs-comment">// 属性只能解构一次，因为let声明变量不能重复</span><br>        <span class="hljs-keyword">let</span> &#123;<br>            weight,<br>            name,<br>            age<br>        &#125; = obj;<br>        <span class="hljs-built_in">console</span>.log(name, age, weight);<br></code></pre></td></tr></table></figure><ul><li>解构后的变量起个别名 : 变量名</li></ul><p>这里冒号左边的name只用来进行属性名匹配， 冒号右边才是真正赋值的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-keyword">let</span> obj = &#123;<br>                name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>                age: <span class="hljs-number">18</span>,<br>                height: <span class="hljs-string">&#x27;175cm&#x27;</span>,<br>                weight: <span class="hljs-string">&#x27;65kg&#x27;</span><br>            &#125;<br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">name</span>: name2,<span class="hljs-attr">height</span>: height1&#125; = obj;<br>       <span class="hljs-built_in">console</span>.log(name2, height1);<span class="hljs-comment">//张三 175cm</span><br></code></pre></td></tr></table></figure><ul><li>从data中结构出来goods对象下的name值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = &#123;<br>               id: <span class="hljs-number">1</span>,<br>               name: <span class="hljs-string">&#x27;家电&#x27;</span>,<br>               goods: &#123;<br>                   id: <span class="hljs-number">3</span>,<br>                   name: <span class="hljs-string">&#x27;TV&#x27;</span><br>               &#125;<br>           &#125;<br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">goods</span>: &#123;name,id&#125;&#125; = data;<br>       <span class="hljs-built_in">console</span>.log(name, id);<br></code></pre></td></tr></table></figure><h3 id="4、箭头函数"><a href="#4、箭头函数" class="headerlink" title="4、箭头函数"></a>4、箭头函数</h3><h4 id="4-1结构（极其简洁）"><a href="#4-1结构（极其简洁）" class="headerlink" title="4.1结构（极其简洁）"></a>4.1结构（极其简洁）</h4><p> () =&gt; {} ；</p><h4 id="4-2-箭头函数的特点"><a href="#4-2-箭头函数的特点" class="headerlink" title="4.2 箭头函数的特点"></a>4.2 箭头函数的特点</h4><ol><li><p>一般不会单独使用, 可以当做匿名函数进行赋值 \ 传参 \ 返回值</p></li><li><p>如果函数体只有一行代码，并代码执行结果就是返回值, 可以同时省略大括号和 return</p></li><li><p>如果形参只有一个, 可以省略小括号</p></li><li><p>内部没有 arguments 这个内置对象</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用箭头函数遍历数组</span><br>       <span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>       <span class="hljs-comment">// 如果形参只有一个, 可以省略小括号</span><br>       arr1.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(item))<br>       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;----------------------&#x27;</span>);<br>       <span class="hljs-comment">// 筛选出数组中所有的偶数</span><br>       <span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<br>       <span class="hljs-keyword">var</span> newArr = arr1.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>           <span class="hljs-built_in">console</span>.log(item);<br>           <span class="hljs-keyword">return</span> item % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>;<br>       &#125;)<br>       <span class="hljs-built_in">console</span>.log(newArr);<br></code></pre></td></tr></table></figure><h4 id="4-3-箭头函数中this指向问题"><a href="#4-3-箭头函数中this指向问题" class="headerlink" title="4.3 箭头函数中this指向问题"></a>4.3 箭头函数中this指向问题</h4><p> (★★★) 箭头函数没有自己的 this, 它里面的 this 指向箭头函数所处位置的 this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>           name: <span class="hljs-string">&#x27;张三&#x27;</span><br>       &#125;<br>       <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">//&#123;name:&#x27;张三&#x27;&#125;  this指向obj</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>               <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">//&#123;name:&#x27;张三&#x27;&#125;   this也指向obj</span><br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">const</span> resFn = fn.call(obj)<br>       resFn()<br></code></pre></td></tr></table></figure><h4 id="★★★-4-4this-情况讨论"><a href="#★★★-4-4this-情况讨论" class="headerlink" title="(★★★)4.4this 情况讨论"></a>(★★★)4.4this 情况讨论</h4><ul><li><p> (1) 非函数中的 this 指向 window</p></li><li><p>(2) es5 中函数的 this 指向函数的调用者</p></li><li><p>(3) call, apply, bind 这三种手动改变 this 的情况特殊对待, this 指向传递的第一个参数</p></li><li><p>(4) es6 中的箭头函数没有自己的 this, 指向所处位置的 this</p></li></ul><h3 id="5、剩余参数"><a href="#5、剩余参数" class="headerlink" title="5、剩余参数"></a>5、剩余参数</h3><h4 id="5-1-剩余参数语法-…变量名"><a href="#5-1-剩余参数语法-…变量名" class="headerlink" title="5.1 剩余参数语法(…变量名)"></a>5.1 剩余参数语法(…变量名)</h4><p>允许我们将剩下的所有参数表示为一个数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//用来计算多个数的和 (1, 2, 3, 4, 5)</span><br>        <span class="hljs-keyword">const</span> getSum = <span class="hljs-function">(<span class="hljs-params">...rest</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(rest);<span class="hljs-comment">//[1, 25, 25, 49]</span><br>            <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>            rest.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> sum += item)<br>            <span class="hljs-built_in">console</span>.log(sum);<br>        &#125;<br>        getSum(<span class="hljs-number">1</span>, <span class="hljs-number">25</span>, <span class="hljs-number">25</span>, <span class="hljs-number">49</span>)<span class="hljs-comment">//100</span><br></code></pre></td></tr></table></figure><h4 id="5-2剩余参数和解构配合使用"><a href="#5-2剩余参数和解构配合使用" class="headerlink" title="5.2剩余参数和解构配合使用"></a>5.2剩余参数和解构配合使用</h4><ul><li>把数组中剩下的元素组成新的数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;black&#x27;</span>]<br><span class="hljs-keyword">let</span> [a, b, ...c] = arr;<br>        <span class="hljs-built_in">console</span>.log(a, b);<span class="hljs-comment">//&#x27;red&#x27; &#x27;orange&#x27;</span><br>        <span class="hljs-built_in">console</span>.log(c);<span class="hljs-comment">//[&#x27;yellow&#x27;, &#x27;green&#x27;, &#x27;black&#x27;]</span><br></code></pre></td></tr></table></figure><ul><li><p>把对象剩下的属性组成一个新对象</p></li><li><p>使用剩余参数快速实现浅拷贝</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>            name: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>            age: <span class="hljs-number">12</span>,<br>            height: <span class="hljs-string">&#x27;170cm&#x27;</span>,<br>            weight: <span class="hljs-string">&#x27;135kg&#x27;</span>,<br>        &#125;<br><span class="hljs-keyword">let</span> &#123; ...obj2&#125; = obj;<br>        <span class="hljs-built_in">console</span>.log(obj2);<span class="hljs-comment">//&#123;name: &quot;小明&quot;, age: 12, height: &quot;170cm&quot;, weight: &quot;135kg&quot;&#125;</span><br><br>        obj2.name = <span class="hljs-string">&#x27;小李&#x27;</span>;<br>        <span class="hljs-built_in">console</span>.log(obj2);<span class="hljs-comment">//&#123;name: &quot;小李&quot;, age: 12, height: &quot;170cm&quot;, weight: &quot;135kg&quot;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="三、ES6-的内置对象扩展"><a href="#三、ES6-的内置对象扩展" class="headerlink" title="三、ES6 的内置对象扩展"></a>三、ES6 的内置对象扩展</h2><h3 id="1、-拓展运算符（展开语法-或-spred运算符）"><a href="#1、-拓展运算符（展开语法-或-spred运算符）" class="headerlink" title="1、 拓展运算符（展开语法 或 spred运算符）"></a>1、 拓展运算符（展开语法 或 spred运算符）</h3><p> …对象名 或 …数组名</p><ul><li><p>作用：把数组或对象转为用逗号分隔的参数形式</p></li><li><p>使用拓展运算符也可以快速完成浅拷贝</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr2 = [...arr1];<br><span class="hljs-built_in">console</span>.log(arr2);<br></code></pre></td></tr></table></figure><h3 id="2、拓展运算符的应用"><a href="#2、拓展运算符的应用" class="headerlink" title="2、拓展运算符的应用"></a>2、拓展运算符的应用</h3><h4 id="2-1用来合并数组"><a href="#2-1用来合并数组" class="headerlink" title="2.1用来合并数组"></a>2.1用来合并数组</h4><ul><li>concat方法</li><li>push方法（直接将最后的合并结果赋值给前者）</li><li>直接利用拓展运算符</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>        <span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>            <span class="hljs-comment">//concat方法</span><br>        <span class="hljs-keyword">const</span> res1 = arr1.concat(arr2);<br>        <span class="hljs-built_in">console</span>.log(res1);<br> <span class="hljs-comment">// push方法</span><br>        <span class="hljs-comment">// arr1.push(...arr2);</span><br>        <span class="hljs-comment">// console.log(arr1);</span><br> <span class="hljs-comment">// 直接利用拓展运算符</span><br>        <span class="hljs-keyword">const</span> res2 = [...arr1, ...arr2]<br>        <span class="hljs-built_in">console</span>.log(res2);<br></code></pre></td></tr></table></figure><h4 id="2-2求数组中的最大值"><a href="#2-2求数组中的最大值" class="headerlink" title="2.2求数组中的最大值"></a>2.2求数组中的最大值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr3 = [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br>       <span class="hljs-keyword">const</span> res3 = <span class="hljs-built_in">Math</span>.max(...arr3);<br>       <span class="hljs-built_in">console</span>.log(res3);<br></code></pre></td></tr></table></figure><h4 id="2-3拓展对象"><a href="#2-3拓展对象" class="headerlink" title="2.3拓展对象"></a>2.3拓展对象</h4><ul><li><p>拓展对象只能在｛｝中</p></li><li><p>合并两个对象，如果有相同的属性，直接后者值覆盖前者</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>           name: <span class="hljs-string">&#x27;Jhon&#x27;</span>,<br>           age: <span class="hljs-number">18</span>,<br>           color: <span class="hljs-string">&#x27;red&#x27;</span><br>       &#125;<br>       <span class="hljs-keyword">const</span> obj1 = &#123;<br>           weight: <span class="hljs-string">&#x27;120kg&#x27;</span>,<br>           height: <span class="hljs-number">180</span>,<br>           color: <span class="hljs-string">&#x27;blue&#x27;</span><br>       &#125;;<br> <span class="hljs-built_in">console</span>.log(&#123;...obj, ...obj1 &#125;); <span class="hljs-comment">//&#123;name: &quot;Jhon&quot;, age: 18, color: &quot;blue&quot;, weight: &quot;120kg&quot;, height: 180&#125;</span><br></code></pre></td></tr></table></figure><h4 id="2-4拓展字符串"><a href="#2-4拓展字符串" class="headerlink" title="2.4拓展字符串"></a>2.4拓展字符串</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>       <span class="hljs-built_in">console</span>.log(...str);<span class="hljs-comment">//h e l l o</span><br></code></pre></td></tr></table></figure><h4 id="2-5使用拓展运算符拓展字符串和伪数组"><a href="#2-5使用拓展运算符拓展字符串和伪数组" class="headerlink" title="2.5使用拓展运算符拓展字符串和伪数组"></a>2.5使用拓展运算符拓展字符串和伪数组</h4><p>结果：为数组，也可以使用forEach进行遍历</p><h3 id="3、模板字符串"><a href="#3、模板字符串" class="headerlink" title="3、模板字符串"></a>3、模板字符串</h3><ul><li>ES6新增的创建字符串的方式，使用反引号定义</li><li>使用 ${变量名或表达式} 代替原来的 ‘引引加加’</li><li>模板字符串支持换行</li><li>在模板字符串中可以放任意的表达式 (如三元表达式, 函数调用, 逻辑运算符, +-*/…)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-keyword">const</span> foo = <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;abc&#x27;</span>;<br>        <span class="hljs-keyword">let</span> str3 = <span class="hljs-string">`hello<span class="hljs-subst">$&#123;<span class="hljs-literal">false</span>?<span class="hljs-string">&#x27;abc&#x27;</span>:<span class="hljs-string">&#x27;ABC&#x27;</span>&#125;</span></span><br><span class="hljs-string"><span class="hljs-subst">$&#123;foo()&#125;</span>`</span>;<br>        <span class="hljs-built_in">console</span>.log(str3);<br></code></pre></td></tr></table></figure><h3 id="4、构造函数方法Array-from"><a href="#4、构造函数方法Array-from" class="headerlink" title="4、构造函数方法Array.from()"></a>4、构造函数方法Array.from()</h3><ul><li>将伪数组或可遍历对象转换为真正的数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>            <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>            <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<br>            length: <span class="hljs-number">2</span><br>        &#125;<br>        <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.from(obj);<br>        <span class="hljs-built_in">console</span>.log(arr);<span class="hljs-comment">//[&quot;a&quot;, &quot;b&quot;]</span><br></code></pre></td></tr></table></figure><ul><li> (了解)第二个可选参数 fn 用于对转化后的数组进行遍历修改</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr2 = <span class="hljs-built_in">Array</span>.from(obj, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(item); <span class="hljs-comment">//a b</span><br>            <span class="hljs-keyword">return</span> item + <span class="hljs-string">&#x27;1&#x27;</span>;<br>        &#125;)<br>        <span class="hljs-built_in">console</span>.log(arr2); <span class="hljs-comment">//[&quot;a1&quot;,&quot;b1&quot;]</span><br></code></pre></td></tr></table></figure><h4 id="4-1-实例方法：find"><a href="#4-1-实例方法：find" class="headerlink" title="4.1.实例方法：find()"></a>4.1.实例方法：find()</h4><ul><li>用于查找数组中符合条件的第一个元素</li><li>返回值: 找到就返回这个元素, 没有找到则返回 undefined</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">44</span>]<br>        <span class="hljs-comment">// 找出大于 10 的第一个元素</span><br><span class="hljs-built_in">console</span>.log(arr.indexOf(<span class="hljs-number">8</span>)); <span class="hljs-comment">//2  返回的是查找的索引号</span><br><span class="hljs-keyword">const</span> res = arr.find(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> item &gt; <span class="hljs-number">10</span>);<br>        <span class="hljs-built_in">console</span>.log(res);<span class="hljs-comment">//12</span><br></code></pre></td></tr></table></figure><h4 id="4-2-findIndex-方法"><a href="#4-2-findIndex-方法" class="headerlink" title="4.2 findIndex() 方法"></a>4.2 findIndex() 方法</h4><ul><li>用于查找数组中符合条件的第一个元素的索引</li><li>返回值: 找到就返回当前元素的所以, 没有找到始终返回 -1</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>]<br>       <span class="hljs-comment">// 找元素中大于 10 的元素索引</span><br>       <span class="hljs-keyword">const</span> res = arr.findIndex(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> item &gt; <span class="hljs-number">10</span>);<br>       <span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><h4 id="4-3includes-固定值-方法"><a href="#4-3includes-固定值-方法" class="headerlink" title="4.3includes(固定值) 方法"></a>4.3includes(固定值) 方法</h4><ul><li>判断数组是否包含给定的值</li><li>返回值: 如果包含则返回 true，否则返回 false</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>]<br>       <span class="hljs-comment">// 判断数组中是否包含 44 这个元素</span><br>       <span class="hljs-built_in">console</span>.log(arr.includes(<span class="hljs-number">44</span>)); <span class="hljs-comment">//true</span><br>       <span class="hljs-built_in">console</span>.log(arr.indexOf(<span class="hljs-number">8</span>) !== -<span class="hljs-number">1</span>); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong> 和其他查找方法的区别 ==&gt; includes 只能接受一个固定值，不能接受一个函数</p><h4 id="4-4map-方法"><a href="#4-4map-方法" class="headerlink" title="4.4map() 方法"></a>4.4map() 方法</h4><ul><li>基于原数组去创建一个新数组,不影响原数组</li><li>返回值: 新数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>];<br><span class="hljs-keyword">const</span> res = arr2.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item / <span class="hljs-number">2</span>);<br><span class="hljs-built_in">console</span>.log(res);<span class="hljs-comment">//[1, 2, 3, 4, 5]</span><br><span class="hljs-built_in">console</span>.log(arr2);<span class="hljs-comment">//[2, 4, 6, 8, 10]不影响原数组</span><br></code></pre></td></tr></table></figure><h4 id="4-5-startsWith-方法"><a href="#4-5-startsWith-方法" class="headerlink" title="4.5 startsWith() 方法"></a>4.5 startsWith() 方法</h4><p>判断字符串是否以某些字符开头，返回 Boolean</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello wrold&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.startsWith(<span class="hljs-string">&#x27;hello&#x27;</span>)); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h4 id="4-6-endsWith-方法："><a href="#4-6-endsWith-方法：" class="headerlink" title="4.6 endsWith() 方法："></a>4.6 endsWith() 方法：</h4><p>判断字符串是否以某些字符结尾，返回 Boolean</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello wrold&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.endsWith(<span class="hljs-string">&#x27;ld&#x27;</span>)); <br></code></pre></td></tr></table></figure><h4 id="4-7-repeat-n-方法"><a href="#4-7-repeat-n-方法" class="headerlink" title="4.7 repeat(n) 方法"></a>4.7 repeat(n) 方法</h4><p>用于将某个字符串重复 n 次, 返回重复后的新字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123&#x27;</span><br>        str = str.repeat(<span class="hljs-number">10</span>);<br>        <span class="hljs-built_in">console</span>.log(str);<br></code></pre></td></tr></table></figure><h3 id="5、Set-数据结构（★★）"><a href="#5、Set-数据结构（★★）" class="headerlink" title="5、Set 数据结构（★★）"></a>5、Set 数据结构（★★）</h3><p>它类似于数组，但<strong>所有的元素都是唯一的，没有重复值</strong></p><h4 id="5-1-语法"><a href="#5-1-语法" class="headerlink" title="5.1 语法"></a>5.1 语法</h4><p> new Set(数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br>       <span class="hljs-built_in">console</span>.log(set); <span class="hljs-comment">//所有的元素都是唯一的，没有重复值</span><br>       <span class="hljs-built_in">console</span>.log(set.size);<span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h4 id="5-2-实例方法"><a href="#5-2-实例方法" class="headerlink" title="5.2 实例方法"></a>5.2 实例方法</h4><ul><li>add(value)：添加某个值，返回 Set 结构本身</li><li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</li><li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员</li><li>clear()：清除所有成员，没有返回值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br> s.add(<span class="hljs-number">1</span>).add(<span class="hljs-number">2</span>).add(<span class="hljs-number">3</span>); <span class="hljs-comment">// 向 set 结构中添加值 </span><br> s.delete(<span class="hljs-number">2</span>)             <span class="hljs-comment">// 删除 set 结构中的2值 </span><br> s.has(<span class="hljs-number">1</span>)                <span class="hljs-comment">// 表示 set 结构中是否有1这个值 返回布尔值 </span><br> s.clear()               <span class="hljs-comment">// 清除 set 结构中的所有值</span><br> <span class="hljs-comment">//注意：删除的是元素的值，不是代表的索引</span><br></code></pre></td></tr></table></figure><ul><li>案例：利用 set 数据类型的不重复性进行数组去重</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 将数组转化为set类型</span><br>        <span class="hljs-keyword">const</span> set2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr);<br>        <span class="hljs-built_in">console</span>.log([...set2]);<br></code></pre></td></tr></table></figure><h4 id="5-3总结-数组去重的方法"><a href="#5-3总结-数组去重的方法" class="headerlink" title="5.3总结: 数组去重的方法"></a>5.3<strong>总结: 数组去重的方法</strong></h4><p>​    （1） 建立一个新数组， 遍历数组， indexOf去判断元素是否存在</p><p>​     (2) filter(fn)</p><p>​     (3)原生for循环进行双重遍历，splice(i,1)</p><p>​    (4)[…new Set(arr)]</p><h4 id="5-3-遍历"><a href="#5-3-遍历" class="headerlink" title="5.3 遍历"></a>5.3 遍历</h4><ul><li>forEach() 方法遍历 set 数据中的每个元素</li><li>for…of 方法遍历任何可迭代的数据( Set, 数组, Map, 字符串)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">const</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]);<br><br>mySet.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(item));<br><br><br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> mySet) &#123;<br>            <span class="hljs-built_in">console</span>.log(item);<br>        &#125;<br><br></code></pre></td></tr></table></figure><p> <strong>注意:</strong> 对象不支持 for..of 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>           a: <span class="hljs-number">1</span>,<br>           b: <span class="hljs-number">2</span>,<br>           c: <span class="hljs-number">3</span><br>       &#125;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj)) &#123;<br>           <span class="hljs-built_in">console</span>.log(item);<span class="hljs-comment">//a b c</span><br>           <span class="hljs-built_in">console</span>.log(obj[item]);<span class="hljs-comment">//1 2 3</span><br>       &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高级第四天</title>
    <link href="/2021/02/04/JS%E9%AB%98%E7%BA%A7%E7%AC%AC4%E5%A4%A9/"/>
    <url>/2021/02/04/JS%E9%AB%98%E7%BA%A7%E7%AC%AC4%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="JS高级第4天"><a href="#JS高级第4天" class="headerlink" title="JS高级第4天"></a>JS高级第4天</h1><h2 id="一、正则表达式概述"><a href="#一、正则表达式概述" class="headerlink" title="一、正则表达式概述"></a>一、正则表达式概述</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>正则表达式（ Regular Expression ）是用于匹配字符串中字符组合的模式，在数据类型中是属于对象</p><h3 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h3><p>正则表达式通常用来校验、查找、替换指定规则的字符文本</p><ul><li><p>验证表单，如：只能输入英文、字母、数字和下划线</p></li><li><p> 过滤页面内容中的敏感词汇，或者对指定字符组合进行替换 </p></li><li><p> 从字符串中提取我们想要的特定部分</p></li></ul><h3 id="3、特点"><a href="#3、特点" class="headerlink" title="3、特点"></a>3、特点</h3><ul><li>灵活性、逻辑性和功能性 （强大）</li><li>简单高效</li><li>可读性稍差，不便于记忆（一般复制相关的正则表达式，修改后即可使用）</li></ul><h2 id="二、正则表达式在js中的使用"><a href="#二、正则表达式在js中的使用" class="headerlink" title="二、正则表达式在js中的使用"></a>二、正则表达式在js中的使用</h2><h3 id="1、正则表达式的创建"><a href="#1、正则表达式的创建" class="headerlink" title="1、正则表达式的创建"></a>1、正则表达式的创建</h3><p>1.造函数方式 RegExp，创建正则表达式 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-regexp">/123/</span>);<br>        <span class="hljs-built_in">console</span>.log(reg);<br></code></pre></td></tr></table></figure><p>2.字面量方式创建正则表达式 /表达式/</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg2 = <span class="hljs-regexp">/123/</span>;<br></code></pre></td></tr></table></figure><h3 id="2、正则表达式的-test-方法"><a href="#2、正则表达式的-test-方法" class="headerlink" title="2、正则表达式的 test 方法"></a>2、正则表达式的 test 方法</h3><p>检测字符串是否符合正则表达式定义的规则，返回 true 或 false</p><ul><li>语法： reg.test(str)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg2 = <span class="hljs-regexp">/123/</span>;<br><span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;刺客123&#x27;</span>));<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h2 id="三、正则表达式中的特殊字符"><a href="#三、正则表达式中的特殊字符" class="headerlink" title="三、正则表达式中的特殊字符"></a>三、正则表达式中的特殊字符</h2><h3 id="1、正则表达式的组成"><a href="#1、正则表达式的组成" class="headerlink" title="1、正则表达式的组成"></a>1、正则表达式的组成</h3><p> 一个正则表达式可以由简单的字符构成，比如 /123/, 也可以是简单和特殊字符的组合，比如：/^abc/</p><p>   其中，特殊字符又叫元字符，是在表达式中有特殊意义的字符，如 ^, $, . 等</p><p>特殊字符非常多，可以参考： </p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">MDN</a></p><h3 id="2、边界符（位置符）"><a href="#2、边界符（位置符）" class="headerlink" title="2、边界符（位置符）"></a>2、边界符（位置符）</h3><p>主要用来匹配字符的开始和结束位置:</p><p>   (1) ^: 用来匹配以…开头</p><p>   (2) $: 用来匹配以…结尾</p><p>注意：</p><ul><li>不使用 ^ 和 $ 表示只要字符串中包含匹配的内容就返回 true, 可以多出其他任意字符</li><li> ^ 和 $ 在一起配合使用，表示是精确匹配, 不能多出其他字符也不能少 (必须满足数量和类型都一致)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg1 = <span class="hljs-regexp">/^567/</span>; <span class="hljs-comment">//字符串中必须以567开头</span><br>     <span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;刺客567&#x27;</span>)); <span class="hljs-comment">//false</span><br>     <span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;561237&#x27;</span>)); <span class="hljs-comment">//false</span><br>     <span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;567刺客&#x27;</span>)); <span class="hljs-comment">//true</span><br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;-------------------------------&#x27;</span>);<br>     <span class="hljs-keyword">var</span> reg2 = <span class="hljs-regexp">/ad$/</span>; <span class="hljs-comment">//字符串中必须以ad结尾</span><br>     <span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;ADad&#x27;</span>)); <span class="hljs-comment">//true</span><br>     <span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;adfgad&#x27;</span>)); <span class="hljs-comment">//true</span><br>     <span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;afgd&#x27;</span>)); <span class="hljs-comment">//false</span><br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;-------------------------------&#x27;</span>);<br>     <span class="hljs-keyword">var</span> reg3 = <span class="hljs-regexp">/^adc$/</span>; <span class="hljs-comment">//字符串中数量和类型必须符合adc</span><br>     <span class="hljs-built_in">console</span>.log(reg3.test(<span class="hljs-string">&#x27;adc&#x27;</span>)); <span class="hljs-comment">//true</span><br>     <span class="hljs-built_in">console</span>.log(reg3.test(<span class="hljs-string">&#x27;adcadc&#x27;</span>)); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h3 id="3、字符类"><a href="#3、字符类" class="headerlink" title="3、字符类"></a>3、字符类</h3><h4 id="3-1、字符集合-如：-xyz"><a href="#3-1、字符集合-如：-xyz" class="headerlink" title="3.1、字符集合 如：[xyz]"></a>3.1、字符集合 如：[xyz]</h4><p>表示匹配字符集合中的任意字符，中括号中只要有任意一个字符出现在字符串就满足规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg1 = <span class="hljs-regexp">/[xyz]123/</span>; <span class="hljs-comment">//规则：只要包含x,y,z中任意一个再跟着123就满足条件</span><br>        <span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;xy123&#x27;</span>)); <span class="hljs-comment">//true</span><br>        <span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;ad123&#x27;</span>)); <span class="hljs-comment">//false</span><br><br> <span class="hljs-keyword">var</span> reg2 = <span class="hljs-regexp">/^[adc]456$/</span>; <span class="hljs-comment">//精确匹配，字符的数量和类型都必须满足（数量：4，类型：a456,b456,c456）</span><br>        <span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;a456&#x27;</span>)); <span class="hljs-comment">//true</span><br>        <span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;b456&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;adc456&#x27;</span>)); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h4 id="3-2中括号中的特殊字符自动转义"><a href="#3-2中括号中的特殊字符自动转义" class="headerlink" title="3.2中括号中的特殊字符自动转义"></a>3.2中括号中的特殊字符自动转义</h4><p>用破折号（-）来指定一个字符范围，如：[c-f1-3A-D]</p><p>注意:</p><ul><li> 对于点（.）和星号（*）这样的特殊符号中括号中自动转义为原本的意义</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg3 = <span class="hljs-regexp">/^[c-f1-3A-D]$/</span>; <span class="hljs-comment">//精确匹配，只能是cdf123ABCD中的一个</span><br>        <span class="hljs-built_in">console</span>.log(reg3.test(<span class="hljs-string">&#x27;asd&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg3.test(<span class="hljs-string">&#x27;cdf&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg3.test(<span class="hljs-string">&#x27;cdf123ABCD&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg3.test(<span class="hljs-string">&#x27;c&#x27;</span>)); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h4 id="3-3反向字符集合"><a href="#3-3反向字符集合" class="headerlink" title="3.3反向字符集合"></a>3.3反向字符集合</h4><p>表示匹配没有包含在字符集合中的字符，字符串中只要有一个不在中括号内的字符就满足规则 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg2 = <span class="hljs-regexp">/^[^a-f]$/</span>; <span class="hljs-comment">//精准匹配（数量1，类型，不在小写a到f之间的其他字符）</span><br>       <span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;a&#x27;</span>)); <span class="hljs-comment">//false</span><br>       <span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;z&#x27;</span>)); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h3 id="4、量词符"><a href="#4、量词符" class="headerlink" title="4、量词符"></a>4、量词符</h3><p>用来制定某个字符出现次数的特殊符号</p><h4 id="4-1"><a href="#4-1" class="headerlink" title="4.1 *"></a>4.1 *</h4><p>表示前面的字符出现 0 次或多次, 即可有可无(数量&gt;=0)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg1 = <span class="hljs-regexp">/^ab*c$/</span>; <span class="hljs-comment">//规则：字符串必须以a开头，b字符可有可无，后面一定跟着c</span><br>        <span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;abbcd&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;abbc&#x27;</span>)); <span class="hljs-comment">//true</span><br>        <span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;ac&#x27;</span>)); <span class="hljs-comment">//true</span><br>        <span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;aac&#x27;</span>)); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h4 id="4-2"><a href="#4-2" class="headerlink" title="4.2 +"></a>4.2 +</h4><p>表示前面的字符至少出现 1 次或多次, 即至少出现一次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg2 = <span class="hljs-regexp">/^ab+c$/</span>; <span class="hljs-comment">//规则：字符串必须以a开头，b字符至少出现一次，后面一定跟着c</span><br>        <span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;abbcd&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;abbc&#x27;</span>)); <span class="hljs-comment">//true</span><br>        <span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;ac&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;aac&#x27;</span>)); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h4 id="4-3"><a href="#4-3" class="headerlink" title="4.3 ?"></a>4.3 ?</h4><p>表示前面的字符出现 0 次或 1 次, 要么不出现, 要么只出现 1 次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg3 = <span class="hljs-regexp">/^[0-9a-z]?$/</span>; <span class="hljs-comment">//规则：字符串必须以0-9或a-z开头，只能出现一次</span><br>        <span class="hljs-built_in">console</span>.log(reg3.test(<span class="hljs-string">&#x27;abbcd&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg3.test(<span class="hljs-string">&#x27;abbc&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg3.test(<span class="hljs-string">&#x27;ac&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg3.test(<span class="hljs-string">&#x27;aac&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg3.test(<span class="hljs-string">&#x27;0&#x27;</span>)); <span class="hljs-comment">//true</span><br>        <span class="hljs-built_in">console</span>.log(reg3.test(<span class="hljs-string">&#x27;a&#x27;</span>)); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h4 id="4-4-3"><a href="#4-4-3" class="headerlink" title="4.4 {3}"></a>4.4 {3}</h4><p>表示前面的字符只能出现 3 次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg4 = <span class="hljs-regexp">/^[0-9a-z]&#123;3&#125;$/</span>; <span class="hljs-comment">//规则：字符串必须以0-9或a-z开头，只能出现3次</span><br>        <span class="hljs-built_in">console</span>.log(reg4.test(<span class="hljs-string">&#x27;abbcd&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg4.test(<span class="hljs-string">&#x27;abbc&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg4.test(<span class="hljs-string">&#x27;ac&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg4.test(<span class="hljs-string">&#x27;aac&#x27;</span>)); <span class="hljs-comment">//true</span><br>        <span class="hljs-built_in">console</span>.log(reg4.test(<span class="hljs-string">&#x27;0&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg4.test(<span class="hljs-string">&#x27;a&#x27;</span>)); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h4 id="4-5-3"><a href="#4-5-3" class="headerlink" title="4.5 {3,}"></a>4.5 {3,}</h4><p>表示前面的字符出现 3 次 或 3次以上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg5 = <span class="hljs-regexp">/^[0-9a-z]&#123;3,&#125;$/</span>; <span class="hljs-comment">//规则：字符串必须以0-9或a-z开头，只能出现3次或三次以上</span><br>        <span class="hljs-built_in">console</span>.log(reg5.test(<span class="hljs-string">&#x27;abbcd&#x27;</span>)); <span class="hljs-comment">//true</span><br>        <span class="hljs-built_in">console</span>.log(reg5.test(<span class="hljs-string">&#x27;abbc&#x27;</span>)); <span class="hljs-comment">//true</span><br>        <span class="hljs-built_in">console</span>.log(reg5.test(<span class="hljs-string">&#x27;ac&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg5.test(<span class="hljs-string">&#x27;aac&#x27;</span>)); <span class="hljs-comment">//true</span><br>        <span class="hljs-built_in">console</span>.log(reg5.test(<span class="hljs-string">&#x27;0&#x27;</span>)); <span class="hljs-comment">//false</span><br>        <span class="hljs-built_in">console</span>.log(reg5.test(<span class="hljs-string">&#x27;a&#x27;</span>)); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h4 id="4-6-3-5"><a href="#4-6-3-5" class="headerlink" title="4.6 {3,5}"></a>4.6 {3,5}</h4><p>表示前面的字符出现 3 次 到 5 次以内</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg6 = <span class="hljs-regexp">/^[0-9a-z]&#123;3,5&#125;$/</span>; <span class="hljs-comment">//规则：字符串必须以0-9或a-z开头，只能出现3到5次</span><br>       <span class="hljs-comment">// 注意&#123;3,5&#125;之间不能有空格</span><br>       <span class="hljs-built_in">console</span>.log(reg6.test(<span class="hljs-string">&#x27;abbcd&#x27;</span>)); <span class="hljs-comment">//true</span><br>       <span class="hljs-built_in">console</span>.log(reg6.test(<span class="hljs-string">&#x27;abbcd123&#x27;</span>)); <span class="hljs-comment">//false</span><br>       <span class="hljs-built_in">console</span>.log(reg6.test(<span class="hljs-string">&#x27;abbc&#x27;</span>)); <span class="hljs-comment">//true</span><br>       <span class="hljs-built_in">console</span>.log(reg6.test(<span class="hljs-string">&#x27;ac&#x27;</span>)); <span class="hljs-comment">//false</span><br>       <span class="hljs-built_in">console</span>.log(reg6.test(<span class="hljs-string">&#x27;aac&#x27;</span>)); <span class="hljs-comment">//true</span><br>       <span class="hljs-built_in">console</span>.log(reg6.test(<span class="hljs-string">&#x27;0&#x27;</span>)); <span class="hljs-comment">//false</span><br>       <span class="hljs-built_in">console</span>.log(reg6.test(<span class="hljs-string">&#x27;a&#x27;</span>)); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h3 id="5、-括号总结"><a href="#5、-括号总结" class="headerlink" title="5、 括号总结"></a>5、 括号总结</h3><ul><li>中括号 [xyz] 字符集合：匹配方括号中的任意字符</li><li> 大括号 {3,8} 量词符：表示重复的次数</li><li>小括号 (xyz): 表示一个整体</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^*(xyz)&#123;2&#125;$/</span>;<br>       <span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">&#x27;xyzxyz&#x27;</span>));<span class="hljs-comment">//true</span><br>       <span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">&#x27;xyzxyzxyz&#x27;</span>));<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h3 id="6、正则表达式中的预定义类"><a href="#6、正则表达式中的预定义类" class="headerlink" title="6、正则表达式中的预定义类"></a>6、正则表达式中的预定义类</h3><ul><li>\d：匹配 0~9 之间的任意一个数字，等价于 [0-9]</li><li>\D: 匹配所有 0~9 之外的字符，等价于 [^0-9]</li><li>\w: 匹配任意的字母、数字和下划线，等价于 [a-zA-Z0-9_]</li><li>\W: 匹配任意的字母、数字和下划线之外的字符，等价于 [^0-9a-zA-Z_]</li><li>\s: 匹配所有的空格（包括换行符，制表符，空格符等），等价于 [\t\r\n\v\f]</li><li> \S：匹配所有的非空格符，等价于 [^\t\r\n\v\f]</li><li> .也是正则中的一个特殊字符：（小数点）默认匹配除换行符之外的任何单个字符</li></ul><p>  <strong>记忆</strong>：所有大写字符表示 “非”, 上述预定义类只表示单个字符</p><h2 id="四、正则替换replace"><a href="#四、正则替换replace" class="headerlink" title="四、正则替换replace"></a>四、正则替换replace</h2><h3 id="1、replace"><a href="#1、replace" class="headerlink" title="1、replace"></a>1、replace</h3><p>replace(reg, 替换后的字符) 可以替换字符串中的字符，参数可以是普通字符串，也可以是正则表达式</p><h3 id="2、正则表达式参数-表达式-参数"><a href="#2、正则表达式参数-表达式-参数" class="headerlink" title="2、正则表达式参数 /表达式/参数"></a>2、正则表达式参数 /表达式/参数</h3><p>指定匹配的模式：</p><p>   （1）/表达式/g  全局匹配</p><p>   （2）/表达式/i  忽略大小写进行匹配</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> placeholder=<span class="hljs-string">&quot;请输入留言&quot;</span>&gt;<br><span class="hljs-keyword">var</span> ipt = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>);<br>ipt.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">this</span>.value = <span class="hljs-built_in">this</span>.value.replace(<span class="hljs-regexp">/傻叉|傻\s*叉|sx/gi</span>, <span class="hljs-string">&#x27;**&#x27;</span>)<br>        &#125;)<br></code></pre></td></tr></table></figure><h3 id="3、match-方法"><a href="#3、match-方法" class="headerlink" title="3、match 方法"></a>3、match 方法</h3><p>可以配合正则表达式, 从字符串中找出所有匹配正则的字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d&#123;3&#125;/g</span>;<br>        <span class="hljs-keyword">var</span> res = str.match(reg);<br>        <span class="hljs-built_in">console</span>.log(res);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高级第一天</title>
    <link href="/2021/02/04/JS%E9%AB%98%E7%BA%A7%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <url>/2021/02/04/JS%E9%AB%98%E7%BA%A7%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="JS高级第一天"><a href="#JS高级第一天" class="headerlink" title="JS高级第一天"></a>JS高级第一天</h1><h2 id="一、面向过程与面向对象"><a href="#一、面向过程与面向对象" class="headerlink" title="一、面向过程与面向对象"></a>一、面向过程与面向对象</h2><h3 id="1、面向过程"><a href="#1、面向过程" class="headerlink" title="1、面向过程"></a>1、面向过程</h3><ul><li>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</li></ul><h3 id="2、面向对象"><a href="#2、面向对象" class="headerlink" title="2、面向对象"></a>2、面向对象</h3><ul><li>面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。</li></ul><h3 id="3、面向过程与面向对象对比"><a href="#3、面向过程与面向对象对比" class="headerlink" title="3、面向过程与面向对象对比"></a>3、面向过程与面向对象对比</h3><p> 面向对象：易于维护、拓展，耦合性低；适用场景：多人合作的复杂项目<br>  面向过程：不易于维护、拓展，耦合性高；适用场景：简单的功能模块</p><h2 id="二、对象和类"><a href="#二、对象和类" class="headerlink" title="二、对象和类"></a>二、对象和类</h2><h3 id="1、对象"><a href="#1、对象" class="headerlink" title="1、对象"></a>1、对象</h3><p>对象是由属性和方法组成的：是一个无序键值对的集合,指的是一个具体的事物</p><ul><li>属性：事物的特征，在对象中用属性来表示（常用名词）</li><li>方法：事物的行为，在对象中用方法来表示（常用动词）</li></ul><h3 id="2、创建对象"><a href="#2、创建对象" class="headerlink" title="2、创建对象"></a>2、创建对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//字面量创建对象</span><br><span class="hljs-keyword">var</span> ldh = &#123;<br>    name: <span class="hljs-string">&#x27;刘德华&#x27;</span>,<br>    age: <span class="hljs-number">18</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(ldh);<span class="hljs-comment">//&#123;name:&quot;刘德华&quot;,age:18&#125;</span><br><br><span class="hljs-comment">//构造函数创建对象</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br> &#125;<br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>)<span class="hljs-comment">//实例化对象</span><br><span class="hljs-built_in">console</span>.log(ldh);<span class="hljs-comment">//Star&#123;name:&quot;刘德华&quot;,age:18&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3、类"><a href="#3、类" class="headerlink" title="3、类"></a>3、类</h3><p>类 (泛指一类事物)：比如运动员，把公共的特征提取出来，封装在一个模板中（姓名，年龄，身高，特长…）</p><p>类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象</p><h3 id="4、创建类"><a href="#4、创建类" class="headerlink" title="4、创建类"></a>4、创建类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 创建类 class  创建一个 明星类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Star</span> </span>&#123;<br>  <span class="hljs-comment">// 类的共有属性放到 constructor 里面</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age;<br>  &#125;<br>&#125;<br>  <span class="hljs-comment">// 2. 利用类创建对象 new</span><br>  <span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>);<br>  <span class="hljs-built_in">console</span>.log(ldh);<span class="hljs-comment">//Star&#123;name:&quot;刘德华&quot;,age:18&#125;</span><br></code></pre></td></tr></table></figure><p>运行结果和使用构造函数方式一样</p><p>注意要点 :</p><ol><li>class 创建的类首字母还是要大写</li><li>类中的 constructor 构造函数, 接收 new 创建对象传递的参数，并返回实例对象（return this） </li><li>new 一个类时，自动调用构造函数方法，但不会自动调用类方法</li><li>类中的构造函数 和 类方法不需要加 function （重点） </li><li>多个类方法之间不需要使用逗号隔开 (重点) </li></ol><h3 id="5、大括号总结"><a href="#5、大括号总结" class="headerlink" title="5、大括号总结"></a>5、大括号总结</h3><ul><li>函数体 fn () {} </li><li>定义对象 var obj = {} </li><li>条件语法 if () {} </li><li>定义一个类 class 类名 {}</li></ul><h3 id="6、类的继承"><a href="#6、类的继承" class="headerlink" title="6、类的继承"></a>6、类的继承</h3><ul><li><p>定义一个类（子类）通过 extends 继承父类上的方法和属性</p><p>​    class 子类名 extends 父类 {}</p></li><li><p>super 关键字可以访问和调用父类上的函数，包括构造函数和类方法</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;<br>           <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age, sex</span>)</span> &#123;<br>               <span class="hljs-built_in">this</span>.name = name;<br>               <span class="hljs-built_in">this</span>.age = age;<br>               <span class="hljs-built_in">this</span>.sex = sex;<br>           &#125;;<br>           <span class="hljs-function"><span class="hljs-title">buy</span>(<span class="hljs-params">phone</span>)</span> &#123;<br>               <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;买了部&#x27;</span> + phone);<br>           &#125;;<br>           <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span> &#123;<br>               <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>           &#125;;<br>       &#125;;<br>       <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">People</span> </span>&#123;<br>           <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age, sex</span>)</span> &#123;<br>               <span class="hljs-comment">// 构造函数中要想使用this， 必须调用super（） 函数， 可以直接把参数传给父亲；</span><br>               <span class="hljs-built_in">super</span>(name, age, sex);<br>           &#125;;<br>           <span class="hljs-comment">// 子类方法</span><br>           <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span> &#123;<br>               <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你好&#x27;</span>);<br>           &#125;;<br>           <span class="hljs-comment">// 子类方法</span><br>           <span class="hljs-function"><span class="hljs-title">intro</span>(<span class="hljs-params"></span>)</span> &#123;<br>               <span class="hljs-comment">// super的第二个方法，可以直接去调用父类上的方法</span><br>               <span class="hljs-built_in">super</span>.say(); <span class="hljs-comment">//hello</span><br>               <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;大家好，我是&#x27;</span> + <span class="hljs-built_in">this</span>.name);<br>           &#125;<br>       &#125;;<br>       <span class="hljs-keyword">var</span> xm = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&#x27;男&#x27;</span>);<br>       <span class="hljs-built_in">console</span>.log(xm);<br>       <span class="hljs-comment">// 如果子类中有和父类中同名的方法，就近使用子类的方法</span><br>       xm.say(); <span class="hljs-comment">//你好</span><br>       xm.intro();<br></code></pre></td></tr></table></figure><p>  <strong>注意：</strong></p><p>​    （1）子类调用方法时的查找顺序：先从子类上找再从父类上找</p><p>​    （2）super 作为一个函数，可以调用父类的构造函数；作为一个对象，可以调用父类的方法</p><p><strong>子类中注意的两点：</strong></p><p>​      1. 子类中使用 this 之前，必须要先调用 super</p><ol start="2"><li>子类可以拓展自己的属性和方法</li></ol><h3 id="7、使用类的两个注意事项"><a href="#7、使用类的两个注意事项" class="headerlink" title="7、使用类的两个注意事项"></a>7、使用类的两个注意事项</h3><p>​    1. 声明 class 类不存在变量提升，先定义再使用</p><ol start="2"><li>在类中访问属性和方法，必须加 this</li></ol><h3 id="8、JS基础this的常见指向问题；"><a href="#8、JS基础this的常见指向问题；" class="headerlink" title="8、JS基础this的常见指向问题；"></a>8、JS基础this的常见指向问题；</h3><ul><li>非函数作用域中的指向：始终指向window；</li><li>函数作用域中的指向：函数的调用者（不关心函数的定义）</li></ul>]]></content>
    
    
    <categories>
      
      <category>JS高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高级第三天</title>
    <link href="/2021/02/04/JS%E9%AB%98%E7%BA%A7%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
    <url>/2021/02/04/JS%E9%AB%98%E7%BA%A7%E7%AC%AC%E4%B8%89%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="JS高级第三天"><a href="#JS高级第三天" class="headerlink" title="JS高级第三天"></a>JS高级第三天</h1><h2 id="一、函数的定义和调用"><a href="#一、函数的定义和调用" class="headerlink" title="一、函数的定义和调用"></a>一、函数的定义和调用</h2><h3 id="1、函数的定义方式"><a href="#1、函数的定义方式" class="headerlink" title="1、函数的定义方式"></a>1、函数的定义方式</h3><ul><li><p>函数的定义方法： </p><p>​      1. 函数声明</p><p>​      2. 函数表达式</p><p>​      3. 利用 Function 构造函数  </p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  1. 函数声明</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> a + b;<br>        &#125;;<br>        <span class="hljs-comment">//   2. 函数表达式</span><br>        <span class="hljs-keyword">var</span> fn1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;123&#x27;</span>);<br>        &#125;;<br>        <span class="hljs-comment">//   3. 利用 Function 构造函数</span><br>        <span class="hljs-keyword">var</span> fn2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;console.log(a+b)&#x27;</span>);<br>        fn2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">console</span>.dir(fn2);<br></code></pre></td></tr></table></figure><h3 id="2、函数调用"><a href="#2、函数调用" class="headerlink" title="2、函数调用"></a>2、函数调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 普通函数</span><br>       <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>);<br>       &#125;<br>       fn1();<br>       <span class="hljs-comment">//   2. 对象中的函数调用</span><br>       <span class="hljs-keyword">var</span> obj = &#123;<br>           say: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>               <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>           &#125;<br>       &#125;;<br>       obj.say();<br>       <span class="hljs-comment">//   3. 构造函数的调用</span><br>       <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>           <span class="hljs-built_in">this</span>.name = name;<br>           <span class="hljs-built_in">this</span>.age = age;<br>       &#125;<br>       <span class="hljs-keyword">var</span> xm = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">12</span>);<br>       <span class="hljs-built_in">console</span>.log(xm);<br>       <span class="hljs-comment">//   4. 绑定事件的处理函数</span><br>       <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);<br>       btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;点击了&#x27;</span>);<br>       &#125;);<br>       <span class="hljs-comment">//   5. 定时器的处理函数 </span><br>       <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;345&#x27;</span>);<br>       &#125;, <span class="hljs-number">1000</span>);<br>       <span class="hljs-comment">//   6. 立即执行函数</span><br>       <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br>       !(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-comment">// 提供了一个局部作用域，和外界的不冲突</span><br>           <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>       &#125;)()<br></code></pre></td></tr></table></figure><h2 id="二、this指向"><a href="#二、this指向" class="headerlink" title="二、this指向"></a>二、this指向</h2><h3 id="1、函数内部this指向"><a href="#1、函数内部this指向" class="headerlink" title="1、函数内部this指向"></a>1、函数内部this指向</h3><ul><li>普通函数                   指向window</li><li>对象中的函数调用       指向调用者</li><li>构造函数的调用           指向实例对象</li><li>绑定事件的处理函数   指向绑定者</li><li>定时器的处理函数       指向window</li><li>立即执行函数                指向window</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;hello&lt;/div&gt;<br>    &lt;button&gt;点击&lt;/button&gt;<br>    &lt;script&gt;<br>        <span class="hljs-comment">// 1. 普通函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//window</span><br>        &#125;<br>        fn1();<br>        <span class="hljs-comment">//   2. 对象中的函数调用</span><br>        <span class="hljs-keyword">var</span> obj = &#123;<br>            say: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>            &#125;<br>        &#125;;<br>        obj.say(); <span class="hljs-comment">//this 指向obj</span><br>        <span class="hljs-keyword">var</span> foo = obj.say;<br>        foo(); <span class="hljs-comment">//this指向window</span><br>        <span class="hljs-comment">//   3. 构造函数的调用</span><br>        <span class="hljs-keyword">var</span> that;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>            that = <span class="hljs-built_in">this</span>;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>        <span class="hljs-keyword">var</span> xm = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-built_in">console</span>.log(xm);<br>        <span class="hljs-built_in">console</span>.log(xm === that);<br>        <span class="hljs-comment">//   4. 绑定事件的处理函数</span><br>        <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);<br>        btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;点击了&#x27;</span>);<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//指向btn</span><br>        &#125;);<br>        <span class="hljs-comment">//   5. 定时器的处理函数 </span><br>        <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//指向window</span><br>        &#125;, <span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">//   6. 立即执行函数</span><br>        <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br>        !(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//指向window</span><br>        &#125;)()<br></code></pre></td></tr></table></figure><h3 id="2、call改变this指向"><a href="#2、call改变this指向" class="headerlink" title="2、call改变this指向"></a>2、call改变this指向</h3><ul><li>fn.call([thisArg, arg1, arg2…])</li><li>作用：调用一个函数，并指定调用时 this 的值</li><li>参数: thisArg 函数中 this 的指定值； arg1, arg2…可选的参数列表</li><li>返回值：函数调用的结果</li></ul><p><strong>注意</strong>：第一个参数 thisArg 如果不传或是 null、undefined，默认函数内 this 指向 window </p><h3 id="3、apply-方法"><a href="#3、apply-方法" class="headerlink" title="3、apply 方法"></a>3、apply 方法</h3><ul><li>fn.apply(thisArg,[ argsArray])</li><li>作用：调用一个函数，并指定调用时 this 的值</li><li>参数: thisArg 函数中 this 的指定值； argsArray 可选的参数数组(!!)</li><li>返回值：函数调用的结果</li></ul><p><strong>和call方法区别</strong>：</p><ul><li>call方法从第二个传递的是每个独立参数，而apply传递的是参数数组</li><li>在可以使用 call 的情况下， 都可以使用 apply 替代 </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-built_in">console</span>.log(a, b);<br>        &#125;<br>        fn.call(&#123;&#125;, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        fn.apply(&#123;&#125;, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br>        <span class="hljs-comment">// 1、使用apply去判断一组数的最大值</span><br>        <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">254</span>, <span class="hljs-number">545</span>, <span class="hljs-number">12</span>, <span class="hljs-number">5</span>];<br>        <span class="hljs-keyword">var</span> res = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, arr);<br>        <span class="hljs-built_in">console</span>.log(res);<br></code></pre></td></tr></table></figure><h3 id="4、-bind方法"><a href="#4、-bind方法" class="headerlink" title="4、 bind方法"></a>4、 bind方法</h3><ul><li>var newFn = fn.bind(thisArg,arg1, arg2, …)</li><li>作用：基于原函数创建一个新函数，这个新函数的 this 被指定为第一个参数， 其余参数作为实参传递给新函数</li><li>参数：thisArg 是新函数内 this 的预设值; arg1, arg2 是新函数预设传入的参数</li><li>返回值: 新函数（本身不会调用函数）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>           <span class="hljs-built_in">console</span>.log(a + b);<br>       &#125;<br>       <span class="hljs-comment">// bind创建一个函数,并且可以为新函数预先指定传入实参</span><br>       <span class="hljs-keyword">var</span> newFn = fn.bind(&#123;&#125;, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>       newFn(); <span class="hljs-comment">//新函数中的this已经被修改为｛｝，并且传入新的参数没用，bind已经预设了</span><br>       fn(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">//原函数中的this 让然指向window</span><br></code></pre></td></tr></table></figure><h2 id="三、严格模式"><a href="#三、严格模式" class="headerlink" title="三、严格模式"></a>三、严格模式</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p> 采用具有限制性JavaScript变体的一种方式，摆脱了以前的松散模式</p><p>​      1. 消除了 js 代码的不合理和不严谨地方，减少怪异行为</p><p>​      2. 消除了代码的不安全地方，保证代码安全运行</p><p>​      3. 提高编译器的效率，增加运行的速度</p><p>​    4.禁用 ECMAScript 未来版本中可能会定义的一些语法 class extends super 等</p><ul><li>使用：在scrip代码块最前面添加’use strict’;</li></ul><h3 id="2、严格模式的变化"><a href="#2、严格模式的变化" class="headerlink" title="2、严格模式的变化"></a>2、严格模式的变化</h3><ul><li>变量未声明不能直接赋值</li><li>变量必须先声明再使用</li><li>函数内的 this 默认指向 undefined</li><li>非函数内的 this 默认指向 undefined</li><li>构造函数和类只能加 new 进行使用</li><li>函数中的参数名不能重名 </li><li>不允许在非函数的代码块内声明函数 (chrome 浏览器没有实现)</li></ul><h2 id="四、高阶函数"><a href="#四、高阶函数" class="headerlink" title="四、高阶函数"></a>四、高阶函数</h2><p>对其他函数进行操作的函数，主要有两种类型的高阶函数：</p><p>​      1. 把函数作为参数的函数</p><ol start="2"><li>把函数作为返回值的函数 </li></ol><h2 id="五、闭包"><a href="#五、闭包" class="headerlink" title="五、闭包"></a>五、闭包</h2><h3 id="1、定义："><a href="#1、定义：" class="headerlink" title="1、定义："></a>1、定义：</h3><p>内部函数访问外部函数声明的变量，这种组合方式就是闭包</p><h3 id="2、JS-中的垃圾回收机制-GC"><a href="#2、JS-中的垃圾回收机制-GC" class="headerlink" title="2、JS 中的垃圾回收机制(GC)"></a>2、JS 中的垃圾回收机制(GC)</h3><p>  垃圾回收机制会定期（周期性）找出那些不再引用到的内存（变量），然后释放其内存</p><h3 id="3、闭包产生的原因"><a href="#3、闭包产生的原因" class="headerlink" title="3、闭包产生的原因"></a>3、闭包产生的原因</h3><p>(1) 当一个函数内的声明的变量没有被其他函数引用时，那么调用完这个函数后，所有的局部变量就会被垃圾回收机制清除；</p><p>​     (2) 一旦这个变量被另外一个函数所引用，这个变量的值会始终保存在内存中，不会被垃圾回收机制回收，从而形成了闭包 </p><h3 id="4、案例："><a href="#4、案例：" class="headerlink" title="4、案例："></a>4、案例：</h3><ul><li>需求: 点击每个按钮弹出当前按钮的索引</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button&gt;按钮&lt;/button&gt;<br>   &lt;button&gt;按钮&lt;/button&gt;<br>   &lt;button&gt;按钮&lt;/button&gt;<br>   &lt;button&gt;按钮&lt;/button&gt;<br>   &lt;button&gt;按钮&lt;/button&gt;<br><br>   &lt;script&gt;<br>       <span class="hljs-comment">// 闭包的应用: 在异步任务中使用同步任务下的变量  </span><br>       <span class="hljs-comment">// 需求: 点击每个按钮弹出当前按钮的索引</span><br>       <span class="hljs-keyword">var</span> btns = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;button&#x27;</span>);<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; btns.length; i++) &#123;<br>           btns[i].index = i;<br>           btns[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>               <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.index);<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">// 闭包应用</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; btns.length; i++) &#123;<br>           <span class="hljs-comment">// 使用立即执行函数去构建闭包，叫做小闭包</span><br>           (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>&#123;<br>               <span class="hljs-comment">// 注意：这里的i就是我们在闭包中去保存的变量，保存了五份</span><br>               btns[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                   <span class="hljs-built_in">console</span>.log(i);<br>               &#125;<br>           &#125;)(i)<br>       &#125;<br></code></pre></td></tr></table></figure><ul><li>计算打车的价格 </li></ul><p>打车起步价 8（3公里内），之后每多一公里增加 5 块钱，用户输入公里数就可以得出打车价格,如果有拥堵的情况，在之前价格的基础上再多收取 10 块钱拥堵费 </p><p>封装一个求正常时打车价格 和 拥挤时打车价格的对象, 并全局中不能访问到起步价和总价 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-keyword">var</span> total = <span class="hljs-number">0</span>;<br>           <span class="hljs-keyword">var</span> start = <span class="hljs-number">8</span>;<br>           <span class="hljs-keyword">return</span> &#123;<br>               price: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">km</span>) </span>&#123;<br>                   total = km &lt;= <span class="hljs-number">3</span> ? start : (km - <span class="hljs-number">3</span>) * <span class="hljs-number">5</span> + start;<br>                   <span class="hljs-keyword">return</span> total;<br>               &#125;,<br>               busyPrice: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">isBusy</span>) </span>&#123;<br>                   total = isBusy ? total + <span class="hljs-number">10</span> : total;<br>                   <span class="hljs-keyword">return</span> total;<br>               &#125;<br>           &#125;<br>       &#125;)()<br>       <span class="hljs-built_in">console</span>.log(obj.price(<span class="hljs-number">20</span>));<br>       <span class="hljs-built_in">console</span>.log(obj.busyPrice(<span class="hljs-literal">true</span>));<br></code></pre></td></tr></table></figure><h2 id="六、递归函数"><a href="#六、递归函数" class="headerlink" title="六、递归函数"></a>六、递归函数</h2><ul><li>函数内部自己调用自己，作用和循环效果类似 </li><li>递归很容易发生 “栈溢出” 错误，所以和 while 循环类似必须要添加中断条件 </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//求 n 到 m 两个数之间的阶乘   5, 10 ===&gt; 5 * 6 * ... * 10</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params">n, m</span>) </span>&#123;<br>           <span class="hljs-keyword">if</span> (n == m) &#123;<br>               <span class="hljs-keyword">return</span> m;<br>           &#125;<br>           <span class="hljs-keyword">return</span> n * fn2(n + <span class="hljs-number">1</span>, m);<br>       &#125;<br>       <span class="hljs-keyword">var</span> res2 = fn2(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br>       <span class="hljs-built_in">console</span>.log(res2);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 利用递归函数求斐波那契数列（兔子序列） 1, 1, 2, 3, 5, 8, 13, 21...</span><br><span class="hljs-comment">// 用户输入一个数字 n 就可以求出这个数字对应的斐波那契数列值  </span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">n</span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> fn(n - <span class="hljs-number">1</span>) + fn(n - <span class="hljs-number">2</span>);<br>            <span class="hljs-comment">// return n==0||n==1?n:fn(n - 1) + fn(n - 2);</span><br>        &#125;<br>        <span class="hljs-built_in">console</span>.log(fn(<span class="hljs-number">4</span>));<br>        <span class="hljs-comment">//fn(3)+fn(2)==&gt;fn(2)+fn(1)+fn(2)==&gt;fn(1)+fn(0)+fn(1)+fn(2)==&gt;fn(1)+fn(0)+fn(1)+fn(1)+fn(0)==&gt;1+0+1+1+0=3</span><br></code></pre></td></tr></table></figure><h2 id="七、拷贝"><a href="#七、拷贝" class="headerlink" title="七、拷贝"></a>七、拷贝</h2><p>简单数据类型都是直接拷贝，不区分深浅拷贝</p><h3 id="1、浅拷贝"><a href="#1、浅拷贝" class="headerlink" title="1、浅拷贝"></a>1、浅拷贝</h3><p>只拷贝对象一层的数据，复杂数据类型只拷贝内存地址值（引用同一个对象）</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>            id: <span class="hljs-number">1</span>,<br>            name: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>            data: &#123;<br>                id: <span class="hljs-number">2</span>,<br>                age: <span class="hljs-number">19</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">var</span> obj2 = &#123;&#125;;<br>        <span class="hljs-comment">// obj2 = obj;</span><br>        <span class="hljs-comment">// 遍历原对象</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>            <span class="hljs-comment">// obj2对象中添加属性</span><br>            obj2[key] = obj[key]<br>        &#125;<br>        obj.data.id = <span class="hljs-number">10</span>; <span class="hljs-comment">//修改原对象data属性下的id值，obj2中的id也会改变</span><br>        <span class="hljs-comment">//这里的data属性值是相同的内存地址</span><br>        <span class="hljs-built_in">console</span>.log(obj2.data.id);<br></code></pre></td></tr></table></figure><h3 id="2、深拷贝"><a href="#2、深拷贝" class="headerlink" title="2、深拷贝"></a>2、深拷贝</h3><ul><li>拷贝对象多层的数据，遇到复杂数据类型会继续新建一个空间，拷贝里面每一层的属性和值 </li></ul><ul><li>和浅拷贝的区别 <ul><li>深拷贝后的对象和原对象是完全隔离的，各自互不影响， 而浅拷贝中所有复杂数据类型的值，都是共同引用的</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj1 = &#123;<br>            id: <span class="hljs-number">1</span>,<br>            name: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>            data: &#123;<br>                id: <span class="hljs-number">2</span>,<br>                age: <span class="hljs-number">19</span>,<br>                goods: &#123;<br>                    id: <span class="hljs-number">10</span><br>                &#125;<br>            &#125;,<br>            arr: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>        &#125;<br>        <span class="hljs-keyword">var</span> obj2 = &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj1, obj2</span>) </span>&#123;<br>            <span class="hljs-comment">// 遍历数组</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj1) &#123;<br>                <span class="hljs-keyword">var</span> temp = obj1[key];<br><br>                <span class="hljs-comment">// 分三种情况讨论</span><br>                <span class="hljs-comment">// 数组==&gt;在obj2中新建数组，再去拷贝</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(temp)) &#123;<br>                    obj2[key] = [];<br>                    deepClone(temp, obj2[key]);<br>                    <span class="hljs-comment">// 对象==&gt;在obj2中新建对象,再去拷贝</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>) &#123;<br>                    obj2 = &#123;&#125;;<br>                    deepClone(temp, obj2[key]);<br>                    <span class="hljs-comment">// 简单数据类型，直接拷贝到obj2中</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    obj2[key] = temp;<br>                &#125;<br>            &#125;<br>        &#125;;<br>        deepClone(obj1, obj2);<br><br>        obj1.data.id = <span class="hljs-number">10</span>;<br>        obj1.arr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;<br><br>        <span class="hljs-comment">// obj2 中的所有数据和obj1中的所有数据完全隔离， 互不影响</span><br>        <span class="hljs-built_in">console</span>.log(obj2.data.id);<br>        <span class="hljs-built_in">console</span>.log(obj2.arr[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><h3 id="3、补充"><a href="#3、补充" class="headerlink" title="3、补充"></a>3、补充</h3><ul><li>浅拷贝快速实现</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>           a: <span class="hljs-number">1</span>,<br>           b: <span class="hljs-number">2</span>,<br>           c: &#123;<br>               d: <span class="hljs-number">4</span><br>           &#125;<br>       &#125;<br>       obj.c.d = <span class="hljs-number">10</span>;<br>       <span class="hljs-keyword">var</span> newObj = &#123;...obj<br>       &#125;;<br>       <span class="hljs-built_in">console</span>.log(newObj);<br><br></code></pre></td></tr></table></figure><ul><li>深拷贝快速实现</li><li>JSON.parse(JSON.stringify(obj))</li><li>JSON.stringify()可以把复杂数据类型转成字符串</li><li>JSON.parse()可以把字符串再转成对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj2 = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj))<br>       obj.c.d = <span class="hljs-number">20</span>;<br>       <span class="hljs-built_in">console</span>.log(obj2); <span class="hljs-comment">//obj2中的属性值不会产生影响</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高级第二天</title>
    <link href="/2021/02/04/JavaScript%E9%AB%98%E7%BA%A7%E7%AC%AC2%E5%A4%A9/"/>
    <url>/2021/02/04/JavaScript%E9%AB%98%E7%BA%A7%E7%AC%AC2%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript高级第2天"><a href="#JavaScript高级第2天" class="headerlink" title="JavaScript高级第2天"></a>JavaScript高级第2天</h1><h2 id="一、构造函数和原型"><a href="#一、构造函数和原型" class="headerlink" title="一、构造函数和原型"></a>一、构造函数和原型</h2><h3 id="1、对象的三种创建方式"><a href="#1、对象的三种创建方式" class="headerlink" title="1、对象的三种创建方式"></a>1、对象的三种创建方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用构造函数创建对象</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">name, age, sex</span>) </span>&#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.age = age;<br>            <span class="hljs-built_in">this</span>.sex = sex;<br>            <span class="hljs-built_in">this</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> People(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">13</span>, <span class="hljs-string">&#x27;男&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(a);<br>        <span class="hljs-comment">// 字面量</span><br>        <span class="hljs-keyword">var</span> obj = &#123;<br>            name: <span class="hljs-string">&#x27;小敏&#x27;</span>,<br>            age: <span class="hljs-number">12</span><br>        &#125;;<br>        <span class="hljs-comment">// new Object()</span><br>        <span class="hljs-keyword">var</span> obj2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>        obj2.name = <span class="hljs-string">&#x27;小红&#x27;</span>;<br>        obj2[<span class="hljs-string">&#x27;age&#x27;</span>] = <span class="hljs-number">12</span>;<br>        <span class="hljs-built_in">console</span>.log(obj2);<br></code></pre></td></tr></table></figure><h3 id="2、静态成员和实例成员"><a href="#2、静态成员和实例成员" class="headerlink" title="2、静态成员和实例成员"></a>2、静态成员和实例成员</h3><ul><li>静态成员：给构造函数添加的属性或方法， 只能通过构造函数本身才能访问的属性或方法</li><li>实例成员：只能通过实例对象才能访问的属性或方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">uname, age, sex</span>) </span>&#123;<br>          <span class="hljs-built_in">this</span>.uname = uname;<br>          <span class="hljs-built_in">this</span>.age = age;<br>          <span class="hljs-built_in">this</span>.sex = sex;<br>          <span class="hljs-built_in">this</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> People(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">13</span>, <span class="hljs-string">&#x27;男&#x27;</span>);<br>      <span class="hljs-comment">// 1. 实例成员: 只能通过实例对象才能访问的属性或方法</span><br>      <span class="hljs-built_in">console</span>.log(a.uname);<br>      <span class="hljs-built_in">console</span>.log(People.uname); <span class="hljs-comment">//undefined ,原因是uname不在People内</span><br>      <span class="hljs-comment">// 2. 静态成员:给构造函数添加的属性或方法， 只能通过构造函数本身才能访问的属性或方法</span><br>      People.height = <span class="hljs-string">&#x27;height&#x27;</span>;<br>      <span class="hljs-built_in">console</span>.log(a.height); <span class="hljs-comment">//undefined ,原因是height不在a内</span><br>      <span class="hljs-built_in">console</span>.log(People.height);<br></code></pre></td></tr></table></figure><h3 id="3、构造函数模型"><a href="#3、构造函数模型" class="headerlink" title="3、构造函数模型"></a>3、构造函数模型</h3><ul><li><p>构造函数中直接添加方法的缺点</p><p>每次创建对象，要重复开辟内存空间，浪费资源 </p></li><li><p>构造函数的原型 prototype</p><p><strong>每个函数默认都有一个 propotype 属性, 它的值默认是一个对象</strong></p><p>在 prototype 对象上的方法和属性, 会被 new 构造函数() 创建出来的实例对象所继承</p></li><li><p>注意:</p><p>​      (1) 只要是函数就默认有 prototype 属性, 但非函数的对象是不具有的</p><p>​      (2) 定义构造函数时, 公共的方法定义在原型对象上, 这样可以被所有创建出来的实例直接继承</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">uname, age</span>) </span>&#123;<br>           <span class="hljs-built_in">this</span>.uname = name;<br>           <span class="hljs-built_in">this</span>.age = age;<br>       &#125;<br>       <span class="hljs-comment">// 每个函数默认都有一个 propotype 属性, 它的值默认是一个对象</span><br>       Student.prototype.sing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;哈哈哈哈&#x27;</span>);<br>       &#125;<br>       Student.prototype.study = <span class="hljs-string">&#x27;学习JS&#x27;</span>;<br>       <span class="hljs-keyword">var</span> xm = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">15</span>);<br>       <span class="hljs-comment">// 在prototype上添加的方法或属性会被所有的实例对象继承</span><br>       <span class="hljs-built_in">console</span>.log(xm.study);<br>       xm.sing();<br>       <span class="hljs-keyword">var</span> obj = &#123;<br>           a: <span class="hljs-number">1</span><br>       &#125;;<br>       <span class="hljs-comment">// console.log(obj.prototype); //非函数没有此属性</span><br></code></pre></td></tr></table></figure><h3 id="4、对象模型"><a href="#4、对象模型" class="headerlink" title="4、对象模型"></a>4、对象模型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">对象的原型<br>    每个对象都默认有一个 __proto__的属性, 它的值是一个对象, 默认指向创建这个对象的构造函数的原型<br><br>对象原型的访问特点<br>     每个对象访问__proto__下的所有属性和方法，可以省略__proto__<br><br>对象上读取属性的顺序<br>      先从自身的属性上进行查找，如果没有再去__proto__属性指向的对象上去查找<br><br></code></pre></td></tr></table></figure><p><img src="E:\黑马培训\前端基础\案例练习\就业班\笔记\JS高级\JS高级第二天\images\img4.png" alt="img4"></p><h3 id="5、constructor构造函数"><a href="#5、constructor构造函数" class="headerlink" title="5、constructor构造函数"></a>5、constructor构造函数</h3><ul><li>对象原型（ __proto__）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。</li><li>constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</li><li>当我们重新建立一个对象去覆盖原先的prototype时，constuctor属性需要我们手动赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">uname, age</span>) </span>&#123;<br>     <span class="hljs-built_in">this</span>.uname = uname;<br>     <span class="hljs-built_in">this</span>.age = age;<br> &#125;<br> <span class="hljs-comment">// 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数</span><br> Star.prototype = &#123;<br> <span class="hljs-comment">// 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数</span><br>   <span class="hljs-title">constructor</span>: <span class="hljs-title">Star</span>, // 手动设置指回原来的构造函数<br>   <span class="hljs-title">sing</span>: <span class="hljs-title">function</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我会唱歌&#x27;</span>);<br>   &#125;,<br>   movie: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我会演电影&#x27;</span>);<br>   &#125;<br>&#125;<br><span class="hljs-keyword">var</span> zxy = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;张学友&#x27;</span>, <span class="hljs-number">19</span>);<br><span class="hljs-built_in">console</span>.log(zxy)<br></code></pre></td></tr></table></figure><h3 id="6、原型链"><a href="#6、原型链" class="headerlink" title="6、原型链"></a>6、原型链</h3><p>每一个实例对象又有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有__proto__属性，这样一层一层往上找就形成了原型链。</p><p><img src="E:\黑马培训\前端基础\案例练习\就业班\笔记\JS高级\JS高级第二天\images\img5.png" alt="img5"></p><h3 id="原型链理解（面试常问）"><a href="#原型链理解（面试常问）" class="headerlink" title="原型链理解（面试常问）"></a><strong>原型链理解（面试常问）</strong></h3><p>  每个实例对象（ object ）都有一个私有属性（称之为 <strong>proto</strong> ）指向创建它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( <strong>proto</strong> ) ，层层向上直到一个对象的原型对象为 null。</p><h3 id="7、原型链和成员的查找机制"><a href="#7、原型链和成员的查找机制" class="headerlink" title="7、原型链和成员的查找机制"></a>7、原型链和成员的查找机制</h3><p>对象访问属性时遵从原型链的顺序</p><p>​    (1) 当访问一个对象的属性时，首先从这个对象自身进行查找</p><p>​    (2) 如果没有找到就从它的原型对象（__proto__）中查找</p><p>​    (3) 如果还没有找到，继续沿着对象的原型链层层向上查找，直到最末尾的 null</p><h3 id="8、原型对象中this指向"><a href="#8、原型对象中this指向" class="headerlink" title="8、原型对象中this指向"></a>8、原型对象中this指向</h3><p>构造函数中的this和原型对象的this,都指向我们new出来的实例对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 非函数中this指向window</span><br>        <span class="hljs-comment">// 函数中this指向函数调用者</span><br>        <span class="hljs-keyword">var</span> that;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">uname, age</span>) </span>&#123;<br>            <span class="hljs-comment">// 函数中的 this 默认指向函数的调用者</span><br>            <span class="hljs-built_in">this</span>.uname = name;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>        <span class="hljs-comment">// 每个函数默认都有一个 propotype 属性, 它的值默认是一个对象</span><br>        Student.prototype.sing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            that = <span class="hljs-built_in">this</span>;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;哈哈哈哈&#x27;</span>);<br>        &#125;<br>        Student.prototype.sleep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === Student.prototype);<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;去睡觉&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">var</span> xm = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">15</span>);<br>        xm.sing();<br>        <span class="hljs-built_in">console</span>.log(that === xm);<br><br>        <span class="hljs-comment">// sing 中this指向调用者Student.prototype</span><br>        Student.prototype.sleep();<br></code></pre></td></tr></table></figure><h3 id="9、原型链的应用：拓展内置对象上自定义方法"><a href="#9、原型链的应用：拓展内置对象上自定义方法" class="headerlink" title="9、原型链的应用：拓展内置对象上自定义方法"></a>9、原型链的应用：拓展内置对象上自定义方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>        <span class="hljs-built_in">console</span>.log(arr.__proto__ === <span class="hljs-built_in">Array</span>.prototype);<br>        arr.push(<span class="hljs-number">4</span>);<br><br>        <span class="hljs-comment">// 1. 需求：修改数组 Array 上的原型对象，添加自定义求和的方法</span><br>        <span class="hljs-built_in">Array</span>.prototype.getSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//指向arr=[1,2,3,4]</span><br>            <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<br>                sum += <span class="hljs-built_in">this</span>[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;<br>        <span class="hljs-built_in">console</span>.log(arr.getSum());<br></code></pre></td></tr></table></figure><p> 拓展原型对象上的方法时，不能直接覆盖原来的原型对象，只能添加或和修改方法 注意：内置对象（如：Object, Array, Function） 上的原型对象不允许进行覆盖，只允许修改</p><h2 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h2><h3 id="1、call"><a href="#1、call" class="headerlink" title="1、call()"></a>1、call()</h3><ul><li>使用：fn.call([thisArg, arg1, arg2…])</li><li>作用：调用一个函数，并指定调用时 this 的值</li><li>参数: thisArg 函数中 this 的指定值； arg1, arg2…可选的参数列表</li><li>返回值：函数调用的结果</li><li>注意：第一个参数 thisArg 如果不传或是 null、undefined，默认函数内 this 指向 window </li></ul><h3 id="2、子构造函数继承父构造函数中的属性"><a href="#2、子构造函数继承父构造函数中的属性" class="headerlink" title="2、子构造函数继承父构造函数中的属性"></a>2、子构造函数继承父构造函数中的属性</h3><ol><li>先定义一个父构造函数</li><li>再定义一个子构造函数</li><li>子构造函数继承父构造函数的属性(使用call方法)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 子类继承父类属性的核心: 使用 call() 把父类的实例对象 this 手动修改为子类的实例对象 this</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//this指向父类创建的实例对象 </span><br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>            <span class="hljs-comment">// this指向子类创建的实例对象</span><br>            People.call(<span class="hljs-built_in">this</span>, name, age);<br>        &#125;<br>        <span class="hljs-keyword">var</span> xm = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">15</span>);<br>        <span class="hljs-built_in">console</span>.log(xm);<br></code></pre></td></tr></table></figure><h3 id="3、借用原型对象继承方法"><a href="#3、借用原型对象继承方法" class="headerlink" title="3、借用原型对象继承方法"></a>3、借用原型对象继承方法</h3><ol><li>先定义一个父构造函数</li><li>再定义一个子构造函数</li><li>子构造函数继承父构造函数的属性(使用call方法)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  子类继承父类上方法的核心: 新建一个对象作为子类的原型对象, 并把这个对象的原型指向父类的 prototype</span><br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//this指向父类创建的实例对象 </span><br>          <span class="hljs-built_in">this</span>.name = name;<br>          <span class="hljs-built_in">this</span>.age = age;<br>      &#125;;<br>      People.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>      &#125;;<br><br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, age, subject</span>) </span>&#123;<br>          <span class="hljs-comment">// this指向子类创建的实例对象</span><br>          People.call(<span class="hljs-built_in">this</span>, name, age);<br>          <span class="hljs-built_in">this</span>.subject = subject;<br>      &#125;;<br>      <span class="hljs-comment">// 三种方法可以调用父类方法：</span><br>      <span class="hljs-comment">// (1)直接把父构造函数的原型拿过来用,但是会导致子类添加的方法，父类也会有</span><br>      Student.prototype = People.prototype;<br><br>      <span class="hljs-comment">// 2） 不能把两个原型放在一个空间， 需要创建一个新的内存空间</span><br>      <span class="hljs-keyword">var</span> obj = &#123;<br>          <span class="hljs-title">constructor</span>: <span class="hljs-title">Student</span>, //把<span class="hljs-title">constructor</span>指向子构造函数<br>          <span class="hljs-title">__proto__</span>: <span class="hljs-title">People</span>.<span class="hljs-title">prototype</span>, //通过原型链，把父构造函数的原型直接拿过来；<br>      &#125;<br>      <span class="hljs-title">Student</span>.<span class="hljs-title">prototype</span> = <span class="hljs-title">obj</span>;<br><br>      <span class="hljs-comment">// (3)实例化父级的构造函数</span><br>      Student.prototype = <span class="hljs-keyword">new</span> People();<br>      Student.prototype.constructor = Student;<br><br>      <span class="hljs-comment">// 子类构造函数原型上添加新的方法</span><br>      Student.prototype.sleep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;去睡觉啊&#x27;</span>);<br>      &#125;<br>      <span class="hljs-keyword">var</span> xm = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">15</span>, <span class="hljs-string">&#x27;语文&#x27;</span>);<br>      xm.say(); <span class="hljs-comment">//xm直接访问父构造函数原型上的方法；</span><br>      <span class="hljs-built_in">console</span>.log(xm);<br>      <span class="hljs-built_in">console</span>.log(People.prototype); <span class="hljs-comment">//检测父构造函数上的原型是否被子构造函数修改</span><br>      <span class="hljs-built_in">console</span>.log(xm.constructor); <span class="hljs-comment">//检测xm是谁创建出来的</span><br></code></pre></td></tr></table></figure><h3 id="4、类的本质"><a href="#4、类的本质" class="headerlink" title="4、类的本质"></a>4、类的本质</h3><ol><li>构造函数默认有一个 prototype 属性, 它的值是一个对象</li><li>构造函数 prototype 属性下有 constructor 和 <strong>proto</strong> 两个默认的属性</li><li>构造函数可以通过在 prototype 上添加方法, 去实现所有实例继承</li><li>构造函数创建的实例上 __proto__指向创建它构造函数的 prototype</li><li>class 类的本质其实就是一个改造版的构造函数</li></ol><h2 id="三、ES5新增数组方法"><a href="#三、ES5新增数组方法" class="headerlink" title="三、ES5新增数组方法"></a>三、ES5新增数组方法</h2><h3 id="1、数组方法forEach遍历数组"><a href="#1、数组方法forEach遍历数组" class="headerlink" title="1、数组方法forEach遍历数组"></a>1、数组方法forEach遍历数组</h3><ul><li>参数：callback(元素, 索引, 数组本身)</li><li>返回值：无</li><li>例子: 使用 forEach 对数组求和</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">55</span>, <span class="hljs-number">13</span>]<br>arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, arr</span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;索引号：&#x27;</span> + index + <span class="hljs-string">&#x27;===&gt;&#x27;</span> + <span class="hljs-string">&#x27;数组元素:&#x27;</span> + item);<br>        &#125;)<br></code></pre></td></tr></table></figure><h3 id="2、filter-方法从数组筛选出符合条件的所有元素"><a href="#2、filter-方法从数组筛选出符合条件的所有元素" class="headerlink" title="2、filter() 方法从数组筛选出符合条件的所有元素"></a>2、filter() 方法从数组筛选出符合条件的所有元素</h3><ul><li>参数：callback(元素, 索引, 数组本身)</li><li>返回值：新数组</li><li>例子: 使用 filter 筛选数组中所有偶数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><span class="hljs-keyword">var</span> newArr = arr2.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item,index</span>) </span>&#123;<br>      <span class="hljs-comment">// 如果return后面的结果为真，就返回到新数组中</span><br><span class="hljs-keyword">return</span> item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>       &#125;)<br>       <span class="hljs-built_in">console</span>.log(newArr);<br></code></pre></td></tr></table></figure><h3 id="3、some-方法用于查找数组中是否有符合条件的某一个元素"><a href="#3、some-方法用于查找数组中是否有符合条件的某一个元素" class="headerlink" title="3、some() 方法用于查找数组中是否有符合条件的某一个元素"></a>3、some() 方法用于查找数组中是否有符合条件的某一个元素</h3><ul><li>参数：callback(元素, 索引, 数组本身)</li><li> 返回值：true(找到) || false(找不到)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;12&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;true&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>]<br>      <span class="hljs-keyword">var</span> a = arr.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>)</span>&#123;<br>           <span class="hljs-keyword">return</span> item == <span class="hljs-string">&#x27;&#x27;</span>;<br>       &#125;)<br>       <span class="hljs-built_in">console</span>.log(a);<br></code></pre></td></tr></table></figure><h3 id="4、-every-方法用于查找数组中是否所有的元素都符合条件"><a href="#4、-every-方法用于查找数组中是否所有的元素都符合条件" class="headerlink" title="4、 every() 方法用于查找数组中是否所有的元素都符合条件"></a>4、 every() 方法用于查找数组中是否所有的元素都符合条件</h3><ul><li>参数：callback(元素, 索引, 数组本身)</li><li>返回值：true || false (只要有一个不满足就返回 false)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr3 = [<span class="hljs-number">30</span>, <span class="hljs-number">22</span>, <span class="hljs-number">45</span>, <span class="hljs-number">16</span>, <span class="hljs-number">20</span>];<br>        <span class="hljs-keyword">var</span> b = arr3.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> item &gt; <span class="hljs-number">20</span>;<br>        &#125;)<br>        <span class="hljs-built_in">console</span>.log(b);<br>        <span class="hljs-comment">// 这些方法本质上都是存在原型上 Array.prototype;</span><br>        <span class="hljs-built_in">console</span>.log(arr3.__proto__ === <span class="hljs-built_in">Array</span>.prototype); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h3 id="5、trim方法去除字符串两端的空格"><a href="#5、trim方法去除字符串两端的空格" class="headerlink" title="5、trim方法去除字符串两端的空格"></a>5、trim方法去除字符串两端的空格</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;   hello   &#x27;</span><br><span class="hljs-built_in">console</span>.log(str.trim()）  <span class="hljs-comment">//hello 去除两端空格</span><br><span class="hljs-keyword">var</span> str1 = <span class="hljs-string">&#x27;   he l l o   &#x27;</span><br><span class="hljs-built_in">console</span>.log(str.trim()）  <span class="hljs-comment">//he l l o  去除两端空格</span><br></code></pre></td></tr></table></figure><h3 id="6、获取对象的属性名"><a href="#6、获取对象的属性名" class="headerlink" title="6、获取对象的属性名"></a>6、获取对象的属性名</h3><p>Object.keys(对象) 获取到当前对象中的属性名 </p><ul><li>返回值是所有属性名组成的数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>          a: <span class="hljs-number">1</span>,<br>          b: <span class="hljs-number">2</span>,<br>          c: <span class="hljs-number">3</span><br>      &#125;;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>          <span class="hljs-built_in">console</span>.log(obj[key]);<br>      &#125;<br>      <span class="hljs-comment">// 1. 使用 Object.keys() 方法获取对象上所有的属性名</span><br>      <span class="hljs-comment">// 返回值：所有属性名组成的数组</span><br>      <span class="hljs-keyword">var</span> res = <span class="hljs-built_in">Object</span>.keys(obj);<br>      <span class="hljs-built_in">console</span>.log(res);<br><br>      <span class="hljs-comment">// 2. 新遍历对象的方法</span><br>      res.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>          <span class="hljs-built_in">console</span>.log(item); <span class="hljs-comment">//获取的是属性名</span><br>          <span class="hljs-built_in">console</span>.log(obj[item]); <span class="hljs-comment">//获取属姓名对应的值，注意都是变量，要用[]</span><br>      &#125;)<br></code></pre></td></tr></table></figure><h3 id="7、Object-defineProperty-方法"><a href="#7、Object-defineProperty-方法" class="headerlink" title="7、Object.defineProperty() 方法"></a>7、Object.defineProperty() 方法</h3><ul><li><p>作用：在对象上定义一个新属性，或者修改原属性，并返回对象</p></li><li><p>使用方法：</p><p>Object.defineProperty(obj, prop, descriptor)</p><p>​      (1) obj: 要定义属性的对象</p><p>​      (2) prop: 要定义或修改的属性的名称, 字符串 ‘name’</p><p>​      (3) descriptor: 要定义或修改的属性描述符, 数据格式是对象 {}</p></li><li><p>属性的描述符：</p><p>(1) value: 属性值 </p><p>(2) writable: 是否可以修改</p><p>(3) enumerable: 是否可以枚举（遍历到）</p><p>(4) configurable: 是否可以删除或再次修改特性</p><p>​      三个属性描述符默认都是 false</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>            name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>            age: <span class="hljs-string">&#x27;12&#x27;</span>,<br>            gender: <span class="hljs-string">&#x27;man&#x27;</span><br>        &#125;<br>        <span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;height&#x27;</span>, &#123;<br>            value: <span class="hljs-string">&#x27;170&#x27;</span>,<br>            writable: <span class="hljs-literal">true</span>, <span class="hljs-comment">//属性可以修改</span><br>            enumerable: <span class="hljs-literal">true</span>, <span class="hljs-comment">//可以遍历到</span><br>            configurable: <span class="hljs-literal">true</span> <span class="hljs-comment">//可以再次修改</span><br>        &#125;)<br>        obj.height = <span class="hljs-string">&#x27;175&#x27;</span>;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(obj));<br>        <span class="hljs-comment">// 删除属性  delete；</span><br>        <span class="hljs-keyword">delete</span> obj.height;<br>        <span class="hljs-built_in">console</span>.log(obj.height);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/01/28/hello-world/"/>
    <url>/2021/01/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
